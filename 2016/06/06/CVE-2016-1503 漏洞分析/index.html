<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>CVE-2016-1503 漏洞分析 | Ericky1992</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="The darkness is no darkness with thee.">
  
  
    <meta name="description" content="CVE-2016-1503 漏洞分析一、漏洞成因首先来看一下官方的描述：    “A vulnerability in the Dynamic Host Configuration Protocol service could enable an attacker to cause memory corruption, which could lead to remote code executi">
  
  <meta name="description" content="CVE-2016-1503 漏洞分析一、漏洞成因首先来看一下官方的描述：    “A vulnerability in the Dynamic Host Configuration Protocol service could enable an attacker to cause memory corruption, which could lead to remote code executi">
<meta name="keywords" content="漏洞 CVE dhcpd DHCP">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2016-1503 漏洞分析">
<meta property="og:url" content="http://yoursite.com/2016/06/06/CVE-2016-1503 漏洞分析/index.html">
<meta property="og:site_name" content="Ericky1992">
<meta property="og:description" content="CVE-2016-1503 漏洞分析一、漏洞成因首先来看一下官方的描述：    “A vulnerability in the Dynamic Host Configuration Protocol service could enable an attacker to cause memory corruption, which could lead to remote code executi">
<meta property="og:image" content="http://img.blog.csdn.net/20170116120936119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170116121406215?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170116121803638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170116121838920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170116121907092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170116121937643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170116122048373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170116122204084?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2017-08-27T16:11:30.886Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2016-1503 漏洞分析">
<meta name="twitter:description" content="CVE-2016-1503 漏洞分析一、漏洞成因首先来看一下官方的描述：    “A vulnerability in the Dynamic Host Configuration Protocol service could enable an attacker to cause memory corruption, which could lead to remote code executi">
<meta name="twitter:image" content="http://img.blog.csdn.net/20170116120936119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Ericky1992</a></h1>
    <p><a href="/">pursue ceaselessly</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/">About</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2016/06/06/CVE-2016-1503 漏洞分析/">
  <time datetime="2016-06-06T04:23:00.000Z">
    2016-06-06
  </time>
</a>
    
    
  
    <h1 class="title">CVE-2016-1503 漏洞分析</h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="CVE-2016-1503-漏洞分析"><a href="#CVE-2016-1503-漏洞分析" class="headerlink" title="CVE-2016-1503 漏洞分析"></a>CVE-2016-1503 漏洞分析</h1><h2 id="一、漏洞成因"><a href="#一、漏洞成因" class="headerlink" title="一、漏洞成因"></a>一、漏洞成因</h2><p>首先来看一下官方的描述：<br>    “A vulnerability in the Dynamic Host Configuration Protocol service could enable an attacker to cause memory corruption, which could lead to remote code execution.”<br>    攻击者可能会通过动态主机配置协议服务中的漏洞破坏内存，从而执行远程代码。</p>
<p>Diff：<br><img src="http://img.blog.csdn.net/20170116120936119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>从官方打下的Patch来看，主要的区别是一个连续的if语句改成了互斥的if else语句，另外一个关键就是之前可以返回除了0或者-1之外的其他值，而patch之后只能返回0或者-1.<br>    通过以上的分析，可以确定了具体的漏洞原因就是dhcpcd在解析options的时候长度dl的校验出现了问题，导致了后续的远程执行漏洞。</p>
<h2 id="二、函数追踪"><a href="#二、函数追踪" class="headerlink" title="二、函数追踪"></a>二、函数追踪</h2><pre><code>定位一下该patch的地方可以得知该Patch的位置在文件dhcp.c中的valid_length(uint8_t option, int dl, int *type)函数里，查找一下valid_length 的引用有一处,是在文件dhcp.c中的get_option(const struct dhcp_message *dhcp, uint8_t opt, int *len, int *type)函数，如下：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">get_option(const struct dhcp_message *dhcp, uint8_t opt, int *len, int *type)</div><div class="line">&#123;</div><div class="line">	const uint8_t *p = dhcp-&gt;options;</div><div class="line">	const uint8_t *e = p + sizeof(dhcp-&gt;options);</div><div class="line">	uint8_t l, ol = 0;</div><div class="line">	uint8_t o = 0;</div><div class="line">	uint8_t overl = 0;</div><div class="line">	uint8_t *bp = NULL;</div><div class="line">	const uint8_t *op = NULL;</div><div class="line">	int bl = 0;</div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line"></div><div class="line">	if (valid_length(opt, bl, type) == -1) &#123;</div><div class="line">		errno = EINVAL;</div><div class="line">		return NULL;</div><div class="line">	&#125;</div><div class="line">	if (len)</div><div class="line">		*len = bl;</div><div class="line">	if (bp) &#123;</div><div class="line">		memcpy(bp, op, ol);</div><div class="line">		return (const uint8_t *)opt_buffer;</div><div class="line">	&#125;</div><div class="line">	if (op)</div><div class="line">		return op;</div><div class="line">	errno = ENOENT;</div><div class="line">	return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码可以看到，只要返回值不为-1，即可通过options的长度校验，也就是说，只要dl % sz 不等于-1即可。sz是根据option的类型来确定，根据不同的类型来取不同的值，如果是UINT32，sz则为4；如果是UINT16，sz则为2，如果是UINIT8，sz则为1。而在valid_length函数中的dl其实就是get_option函数中的bl，这个值是服务器发出来的数据包中单个option的长度。在校验完bl的长度后，将会把这个bl的值赋给get_option函数中的第三个参数<em>len。<br>    接下来我们继续追踪这个指针len，查找get_option函数的引用，在dhcp.c文件中一共有7处，排除之后找到configure_env(char **env, const char </em>prefix, const struct dhcp_message <em>dhcp, const struct if_options </em>ifo)函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">configure_env(char **env, const char *prefix, const struct dhcp_message *dhcp,</div><div class="line">    const struct if_options *ifo)</div><div class="line">&#123;</div><div class="line">	unsigned int i;</div><div class="line">	const uint8_t *p;</div><div class="line">	int pl;</div><div class="line">	struct in_addr addr;</div><div class="line">	struct in_addr net;</div><div class="line">	struct in_addr brd;</div><div class="line">	char *val, *v;</div><div class="line">	const struct dhcp_opt *opt;</div><div class="line">	ssize_t len, e = 0;</div><div class="line">	char **ep;</div><div class="line">	char cidr[4];</div><div class="line">	uint8_t overl = 0;</div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line">	//循环读取options</div><div class="line">	for (opt = dhcp_opts; opt-&gt;option; opt++) &#123;</div><div class="line">		if (!opt-&gt;var)</div><div class="line">			continue;</div><div class="line">		if (has_option_mask(ifo-&gt;nomask, opt-&gt;option))</div><div class="line">			continue;</div><div class="line">		val = NULL;</div><div class="line">		p = get_option(dhcp, opt-&gt;option, &amp;pl, NULL);</div><div class="line">		if (!p)</div><div class="line">			continue;</div><div class="line">		/* We only want the FQDN name */</div><div class="line">		if (opt-&gt;option == DHO_FQDN) &#123;</div><div class="line">			p += 3;</div><div class="line">			pl -= 3;</div><div class="line">		&#125;</div><div class="line">		len = print_option(NULL, 0, opt-&gt;type, pl, p);</div><div class="line">		if (len &lt; 0)</div><div class="line">			return -1;</div><div class="line">		e = strlen(prefix) + strlen(opt-&gt;var) + len + 4;</div><div class="line">		v = val = *ep++ = xmalloc(e);</div><div class="line">		v += snprintf(val, e, &quot;%s_%s=&quot;, prefix, opt-&gt;var);</div><div class="line">		if (len != 0)</div><div class="line">			print_option(v, len, opt-&gt;type, pl, p);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return ep - env;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上代码可以看到，之前的校验出现了问题的bl，其实赋值给了pl，而pl在configure_env函数中为一个局部变量，在调用get_option 函数给pl赋值后，后来又2次调用print_option函数，并传入了pl参数。接下来就是来跟踪一下这个pl的值，查看print_option(char <em>s, ssize_t len, int type, int dl, const uint8_t </em>data)函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">print_option(char *s, ssize_t len, int type, int dl, const uint8_t *data)</div><div class="line">&#123;</div><div class="line">	const uint8_t *e, *t;</div><div class="line">	uint16_t u16;</div><div class="line">	int16_t s16;</div><div class="line">	uint32_t u32;</div><div class="line">	int32_t s32;</div><div class="line">	struct in_addr addr;</div><div class="line">	ssize_t bytes = 0;</div><div class="line">	ssize_t l;</div><div class="line">	char *tmp;</div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line"></div><div class="line">	if (!s) &#123;</div><div class="line">		if (type &amp; UINT8)</div><div class="line">			l = 3;</div><div class="line">		else if (type &amp; UINT16) &#123;</div><div class="line">			l = 5;</div><div class="line">			dl /= 2;</div><div class="line">		&#125; else if (type &amp; SINT16) &#123;</div><div class="line">			l = 6;</div><div class="line">			dl /= 2;</div><div class="line">		&#125; else if (type &amp; UINT32) &#123;</div><div class="line">			l = 10;</div><div class="line">			dl /= 4;</div><div class="line">		&#125; else if (type &amp; SINT32) &#123;</div><div class="line">			l = 11;</div><div class="line">			dl /= 4;</div><div class="line">		&#125; else if (type &amp; IPV4) &#123;</div><div class="line">			l = 16;</div><div class="line">			dl /= 4;</div><div class="line">		&#125; else &#123;</div><div class="line">			errno = EINVAL;</div><div class="line">			return -1;</div><div class="line">		&#125;</div><div class="line">		return (l + 1) * dl; //第一次调用 print_option在这里返回</div><div class="line">	&#125;</div><div class="line">//第二次调用 print_option函数才可以到这里</div><div class="line">	t = data;</div><div class="line">	e = data + dl;</div><div class="line">	while (data &lt; e) &#123;</div><div class="line">		if (data != t) &#123;</div><div class="line">			*s++ = &apos; &apos;;</div><div class="line">			bytes++;</div><div class="line">			len--;</div><div class="line">		&#125;</div><div class="line">		if (type &amp; UINT8) &#123;</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, *data);</div><div class="line">			data++;</div><div class="line">		&#125; else if (type &amp; UINT16) &#123;</div><div class="line">			memcpy(&amp;u16, data, sizeof(u16));</div><div class="line">			u16 = ntohs(u16);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, u16);</div><div class="line">			data += sizeof(u16);</div><div class="line">		&#125; else if (type &amp; SINT16) &#123;</div><div class="line">			memcpy(&amp;s16, data, sizeof(s16));</div><div class="line">			s16 = ntohs(s16);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, s16);</div><div class="line">			data += sizeof(s16);</div><div class="line">		&#125; else if (type &amp; UINT32) &#123;</div><div class="line">			memcpy(&amp;u32, data, sizeof(u32));</div><div class="line">			u32 = ntohl(u32);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, u32);</div><div class="line">			data += sizeof(u32);</div><div class="line">		&#125; else if (type &amp; SINT32) &#123;</div><div class="line">			memcpy(&amp;s32, data, sizeof(s32));</div><div class="line">			s32 = ntohl(s32);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, s32);</div><div class="line">			data += sizeof(s32);</div><div class="line">		&#125; else if (type &amp; IPV4) &#123;</div><div class="line">			memcpy(&amp;addr.s_addr, data, sizeof(addr.s_addr));</div><div class="line">			l = snprintf(s, len, &quot;%s&quot;, inet_ntoa(addr));</div><div class="line">			data += sizeof(addr.s_addr);</div><div class="line">		&#125; else</div><div class="line">			l = 0;</div><div class="line">		if (len &lt;= l) &#123;</div><div class="line">			bytes += len;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		len -= l;</div><div class="line">		bytes += l;</div><div class="line">		s += l;</div><div class="line">	&#125;</div><div class="line">	return bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述的代码可以看到，第一次的调用将会在”return (l + 1) * dl ”这里返回，并且会返回一个len作为第二次调用的第二个参数再次传入print_option函数。第二次调用print_option函数的时候，dl的值影响了while循环，这个循环在第一次调用print_option函数是无法进入的。<br>    分析到这里，可以推断之前在valid_length函数中未合理校验的dl值传入到了此while循环中，正是由于之前的校验不够完整使得在此while循环中dl的值不合法，最终导致了该漏洞的形成。<br>整个在客户端的过程如图所示：</p>
<p><img src="http://img.blog.csdn.net/20170116121406215?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="三、测试环境的搭建"><a href="#三、测试环境的搭建" class="headerlink" title="三、测试环境的搭建"></a>三、测试环境的搭建</h2><pre><code>由于该漏洞的特殊性，需要开启一个热点，搭建一个Dhcpd服务器以及一个带log的dhcpcd的客户端来验证此漏洞，这里选用的系统为Ubuntu14.04。
</code></pre><p>3.1 Hostapd热点的搭建</p>
<p>安装Hostapd：<br>sudo apt-get install hostapd</p>
<p>安装了软件以后，在/etc/hostapd文件夹中建立一个hostapd.conf的文件，在里面写入接入点的信息。<br>配置Hostapd：<br>sudo nano /etc/hostapd/hostapd.conf</p>
<p>hostapd.conf文件改成如下：</p>
<hr>
<p>interface=wlan0//改成对应的网卡<br>driver=nl80211//这个driver一定得是这个<br>ssid=baobaonihao<br>hw_mode=g<br>channel=10<br>macaddr_acl=0<br>auth_algs=3<br>wpa=2<br>wpa_passphrase=qqqq1111<br>wpa_key_mgmt=WPA-PSK<br>wpa_pairwise=TKIP CCMP<br>rsn_pairwise=TKIP CCMP</p>
<hr>
<p>注意要自己设置其中的无线热点名称ssid和认证密码wpa_passphrase。</p>
<pre><code>上述配置完成以后，在终端执行sudo hostapd /etc/hostapd/hostapd.conf -B(-B是需要在后台运行的时候添加)，到这里，就表明Hostapd的安装和配置结束了，现在已经可以在手机终端上可以搜索到这个baobaonihao 的热点了，但是无法连接到这个热点，此时应该出现的情况是：正在获取IP地址，但是一直获取不到。这是由于dhcpd服务器没搭建好的原因，接下来就是dhcpd服务器的搭建。
</code></pre><p>3.2 Dhcpd服务器的编译与搭建<br>    这个dhcpd服务器不能直接用apt-get来安装，可以在官网<a href="https://www.isc.org/" target="_blank" rel="external">https://www.isc.org/</a> 里面找到源码并且下载，进行编译安装。<br>    下载之后为一个dhcp-4.3.4.tar.gz包。<br>安装官方原始版本如下：<br>tar zxvf dhcp-4.3.4.tar.gz</p>
<p>cd dhcp-4.3.4</p>
<p>chmod 777 configure</p>
<p>sudo ./configure</p>
<p>sudo make </p>
<p>sudo make install</p>
<p>安装debug版本如下，debug版本能输出log，在之后的构建package中方便查看调试以及log信息：</p>
<p>tar zxvf dhcp-4.3.4.tar.gz</p>
<p>cd dhcp-4.3.4</p>
<p>chmod 777 configure</p>
<p>sudo ./configure –enable-debug</p>
<p>sudo make </p>
<p>sudo make install</p>
<p>这样就可以编译安装一个调试版本了。</p>
<p>同样的，安装了软件以后，在/etc/dhcp文件夹中建立一个dhcpd.conf的配置文件，在里面写入dhcpd的配置信息。</p>
<p>dhcpd.conf文件改成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">************************</div><div class="line">ddns-update-style none;</div><div class="line">log-facility local7;</div><div class="line"></div><div class="line">subnet 172.20.94.0 netmask 255.255.255.0 &#123;</div><div class="line">        option routers                  172.20.94.1;</div><div class="line">        option subnet-mask              255.255.255.0;</div><div class="line">        option broadcast-address        172.20.94.255;</div><div class="line">	option domain-name &quot;internal.baidu.com&quot;;</div><div class="line">        option domain-name-servers      172.22.1.253,172.22.1.254;</div><div class="line">        option ntp-servers              172.20.94.1;</div><div class="line">        option netbios-name-servers     172.20.94.1;</div><div class="line">        option netbios-node-type 2;</div><div class="line">        default-lease-time 86400;</div><div class="line">        max-lease-time 86400;</div><div class="line">	range 172.20.94.0 172.20.94.100;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述配置完成以后我们需要手动给wlan0配置IP地址并且启动它，在终端输入：</p>
<p>sudo ifconfig wlan0 172.20.94.1 </p>
<p>sudo dhcpd /etc/dhcp/dhcpd.conf</p>
<p>就可以启动dhcpd了，此时可以获取到ip地址了，已经可以成功发包了，如果要上网，则还要输入以下命令：</p>
<p>开启内核IP转发<br>bash -c “echo 1 &gt; /proc/sys/net/ipv4/ip_forward”<br> 开启防火墙NAT转发(如果本机使用eth0上网,则把ppp0改为eth0)<br>iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE</p>
<p>这样Dhcpd服务器的编译与搭建到此就完成了，以及可以修改源码取任意构造数据包了。</p>
<p>3.3 Dhcpcd客户端增加log编译。<br>    采用4.4.4版本的源码来编译<br>log函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void MYLOG(const char* ms, ...);</div><div class="line">void MYLOG(const char* ms, ...)  </div><div class="line">&#123;  </div><div class="line">    char wzLog[1024] = &#123;0&#125;;  </div><div class="line">    char buffer[1024] = &#123;0&#125;;  </div><div class="line">    va_list args;  </div><div class="line">    va_start(args, ms);  </div><div class="line">    vsprintf( wzLog ,ms,args);  </div><div class="line">    va_end(args);  </div><div class="line"> </div><div class="line">    time_t now;  </div><div class="line">    time(&amp;now);  </div><div class="line">    struct tm *local;  </div><div class="line">    local = localtime(&amp;now);  </div><div class="line">    sprintf(buffer,&quot;%04d-%02d-%02d %02d:%02d:%02d %s\n&quot;, local-&gt;tm_year+1900, local-&gt;tm_mon,  </div><div class="line">                local-&gt;tm_mday, local-&gt;tm_hour, local-&gt;tm_min, local-&gt;tm_sec,  </div><div class="line">                wzLog);  </div><div class="line">    FILE* file = fopen(&quot;/data/local/tmp/dhcplog&quot;,&quot;a+&quot;);  </div><div class="line">    fwrite(buffer,1,strlen(buffer),file);  </div><div class="line">    fclose(file);  </div><div class="line"> </div><div class="line">  // syslog(LOG_INFO,wzLog);  </div><div class="line">    return ;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译的话直接make即可编译</p>
<h2 id="四、dhcp发包交互过程"><a href="#四、dhcp发包交互过程" class="headerlink" title="四、dhcp发包交互过程"></a>四、dhcp发包交互过程</h2><pre><code>要想触发该漏洞，当然得了解dhcp服务器与客户端之间的交互。那它们之间是怎么样交互的呢？    DHCP协议采用UDP作为传输协议，主机发送请求消息到DHCP服务器的67号端口，DHCP服务器回应应答消息给主机的68号端口。
</code></pre><p>DHCP Client以广播的方式发出DHCP Discover报文。</p>
<p>所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。<br>DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。</p>
<p>DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。<br>DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。</p>
<p>DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。</p>
<p>DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。</p>
<p>DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。</p>
<pre><code>可以得知DHCP  Server会向DHCP Client响应一个DHCP ACK报文，而这个ACK报文能触发到漏洞代码片段，而需要知道的就是如何构建自己的DHCP ACK报文。查看Server端的代码，找到处理客户端报文的函数为void dhcp (struct packet *packet) ，代码片段如下：
</code></pre><p><img src="http://img.blog.csdn.net/20170116121803638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>对应的ACK 报文当然是DHCPREQUEST，继续查看dhcprequest函数，在结尾处找到:<br><img src="http://img.blog.csdn.net/20170116121838920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以发现，是ack_lease (packet, lease, DHCPACK, 0, msgbuf, ms_nulltp,(struct host_decl *)0);这个函数，继续追踪，还是在尾部：</p>
<p><img src="http://img.blog.csdn.net/20170116121907092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>进入dhcp_reply(lease),继续追踪：</p>
<p><img src="http://img.blog.csdn.net/20170116121937643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>进入cons_options函数，还是在函数的尾部发现：<br>    memcpy(outpacket-&gt;options, buffer, index);</p>
<pre><code>length = DHCP_FIXED_NON_UDP + index;

return length;


这里的buffer就是储存数据包中options字段的地方了，在这个memcpy之前改写这个buffer，再对应的把index改成数据包中options字段实际的长度就可以了。
</code></pre><h2 id="五、发包验证"><a href="#五、发包验证" class="headerlink" title="五、发包验证"></a>五、发包验证</h2><pre><code>可以先发个包熟悉一下格式是什么样的（Hex格式）：
</code></pre><p><img src="http://img.blog.csdn.net/20170116122048373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>表示的是一个完整的DHCP ACK 数据包，这个数据包的格式如下：<br>0                   1                   2                   3<br>   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>   |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |<br>   +—————+—————+—————+—————+<br>   |                            xid (4)                            |<br>   +——————————-+——————————-+<br>   |           secs (2)            |           flags (2)           |<br>   +——————————-+——————————-+<br>   |                          ciaddr  (4)                          |<br>   +—————————————————————+<br>   |                          yiaddr  (4)                          |<br>   +—————————————————————+<br>   |                          siaddr  (4)                          |<br>   +—————————————————————+<br>   |                          giaddr  (4)                          |<br>   +—————————————————————+<br>   |                                                               |<br>   |                          chaddr  (16)                         |<br>   |                                                               |<br>   |                                                               |<br>   +—————————————————————+<br>   |                                                               |<br>   |                          sname   (64)                         |<br>   +—————————————————————+<br>   |                                                               |<br>   |                          file    (128)                        |<br>   +—————————————————————+<br>   |                                                               |<br>   |                          options (variable)                   |<br>   +—————————————————————+</p>
<p>具体参数含义请参考rfc2131[1]文档，这里关注的是最后一个字段options，这个字段就是导致漏洞触发的关键点。</p>
<p>为了顺利的利用长度校验不合理的这个缺陷，可以把opt-&gt;type设置成UINT16和ARRAY，查找一下这种type的option在客户端的源码对应的option号码，如下：<br><img src="http://img.blog.csdn.net/20170116122204084?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGs5MjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>option的号码为25，为了清楚25这个option的格式，查看rfc2132[2]文档找到描述如下：</p>
<p>4.7. Path MTU Plateau Table Option</p>
<p>   This option specifies a table of MTU sizes to use when performing<br>   Path MTU Discovery as defined in RFC 1191.  The table is formatted as<br>   a list of 16-bit unsigned integers, ordered from smallest to largest.<br>   The minimum MTU value cannot be smaller than 68.</p>
<p>   The code for this option is 25.  Its minimum length is 2, and the<br>   length MUST be a multiple of 2.</p>
<pre><code>Code   Len     Size 1      Size 2
</code></pre><p>   +—–+—–+—–+—–+—–+—–+—<br>   |  25 |  n  |  s1 |  s2 |  s1 |  s2 | …<br>   +—–+—–+—–+—–+—–+—–+—<br>    从上述的描述可以得知最小长度n规定为2，且长度为2的整数倍。但是可以构建一个option为25长度为3的数据包，既可以在长度校验函数中返回1从而通过校验，又能进入print_option函数中的while循环，当进入while循环后如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">t = data;</div><div class="line">	e = data + dl;</div><div class="line">	while (data &lt; e) &#123;</div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line">	else if (type &amp; UINT16) &#123;</div><div class="line">			memcpy(&amp;u16, data, sizeof(u16));</div><div class="line">			u16 = ntohs(u16);</div><div class="line">			l = snprintf(s, len, &quot;%d&quot;, u16);</div><div class="line">			data += sizeof(u16);</div><div class="line">		&#125; </div><div class="line"></div><div class="line">	…...</div><div class="line"></div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>dl为3，而data每次循环后只加了2，导致了此while循环多循环了一次，memcpy多copy了一次2字节，造成了越界。至此整个漏洞就分析完毕。</p>
<pre><code>By Ericky

2016.06.06
</code></pre><p>参考链接：</p>
<p>[1] <a href="https://tools.ietf.org/html/rfc2131" target="_blank" rel="external">https://tools.ietf.org/html/rfc2131</a></p>
<p>[2] <a href="https://tools.ietf.org/html/rfc2132" target="_blank" rel="external">https://tools.ietf.org/html/rfc2132</a></p>
<p>[3] <a href="https://android.googlesource.com/platform/external/dhcpcd/+/1390ace71179f04a09c300ee8d0300aa69d9db09" target="_blank" rel="external">https://android.googlesource.com/platform/external/dhcpcd/+/1390ace71179f04a09c300ee8d0300aa69d9db09</a></p>
<p>[4] <a href="http://source.android.com/security/bulletin/2016-04-02.html" target="_blank" rel="external">http://source.android.com/security/bulletin/2016-04-02.html</a></p>
<p>[5] <a href="http://www.isc.org/downloads/" target="_blank" rel="external">http://www.isc.org/downloads/</a></p>
<p>[6] <a href="https://help.ubuntu.com/community/isc-dhcp-server" target="_blank" rel="external">https://help.ubuntu.com/community/isc-dhcp-server</a></p>

    
  </div>
  <footer>
    
      
  <div class="categories">
    <a class="categories-link" href="/categories/Android/">Android</a>
  </div>

      
  <div class="tags">
    <a class="tags-link" href="/tags/漏洞-CVE-dhcpd-DHCP/">漏洞 CVE dhcpd DHCP</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2017 <a href="/">The darkness is no darkness with thee.</a>
  
</div>
<div class="theme-copyright">

</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>